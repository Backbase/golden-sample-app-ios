//
// AccountAggregatedBalance.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import ClientCommonGen2

/** DEPRECATED. To be removed in 2.21.0. Please use AggregatedBalances type. */
public struct AccountAggregatedBalance: Codable, Equatable {
    /** A unique identifier of instance from the grouped by parameter */
    public var id: String?
    /** Localized product kind name that will be filled when aggregations are grouped by product kind. */
    public var productKindName: String?
    /** Balance type for the aggregated balances. */
    public var balanceType: String?
    /** Number of arrangements that are aggregated for this group. */
    public var numberOfArrangements: Int?
    /** List of aggregated balance amount per currency code. */
    public var aggregatedBalances: [AggregatedBalance]?
    public var additions: [String: String]?

    @available(*, deprecated, message: "This initializer is deprecated, use the initializer and the setters of AccountAggregatedBalance.Builder class.")
    public init(id: String? = nil, productKindName: String? = nil, balanceType: String? = nil, numberOfArrangements: Int? = nil, aggregatedBalances: [AggregatedBalance]? = nil, additions: [String: String]? = nil) {
        self.id = id
        self.productKindName = productKindName
        self.balanceType = balanceType
        self.numberOfArrangements = numberOfArrangements
        self.aggregatedBalances = aggregatedBalances
        self.additions = additions
    }

    /// Builder class for AccountAggregatedBalance DTO.
    public final class Builder: Equatable {
        /** A unique identifier of instance from the grouped by parameter */
        public private(set) var id: String?
        /** Localized product kind name that will be filled when aggregations are grouped by product kind. */
        public private(set) var productKindName: String?
        /** Balance type for the aggregated balances. */
        public private(set) var balanceType: String?
        /** Number of arrangements that are aggregated for this group. */
        public private(set) var numberOfArrangements: Int?
        /** List of aggregated balance amount per currency code. */
        public private(set) var aggregatedBalances: [AggregatedBalance]?
        public private(set) var additions: [String: String]?

        public init() {
        }

        /// Setter method for id property.
        public func set(id: String?) -> Self {
            self.id = id
            return self
        }
        /// Setter method for productKindName property.
        public func set(productKindName: String?) -> Self {
            self.productKindName = productKindName
            return self
        }
        /// Setter method for balanceType property.
        public func set(balanceType: String?) -> Self {
            self.balanceType = balanceType
            return self
        }
        /// Setter method for numberOfArrangements property.
        public func set(numberOfArrangements: Int?) -> Self {
            self.numberOfArrangements = numberOfArrangements
            return self
        }
        /// Setter method for aggregatedBalances property.
        public func set(aggregatedBalances: [AggregatedBalance]?) -> Self {
            self.aggregatedBalances = aggregatedBalances
            return self
        }
        /// Setter method for additions property.
        public func set(additions: [String: String]?) -> Self {
            self.additions = additions
            return self
        }

        /// Builder initializer method for AccountAggregatedBalance DTO.
        public func build() -> AccountAggregatedBalance {
            return AccountAggregatedBalance(id: id, 
                    productKindName: productKindName, 
                    balanceType: balanceType, 
                    numberOfArrangements: numberOfArrangements, 
                    aggregatedBalances: aggregatedBalances, 
                    additions: additions)
        }

        public static func ==(lhs: Builder, rhs: Builder) -> Bool {
            return lhs.id == rhs.id &&
            lhs.productKindName == rhs.productKindName &&
            lhs.balanceType == rhs.balanceType &&
            lhs.numberOfArrangements == rhs.numberOfArrangements &&
            lhs.aggregatedBalances == rhs.aggregatedBalances &&
            lhs.additions == rhs.additions
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: String.self)
        try container.encodeIfPresent(id, forKey: "id")
        try container.encodeIfPresent(productKindName, forKey: "productKindName")
        try container.encodeIfPresent(balanceType, forKey: "balanceType")
        try container.encodeIfPresent(numberOfArrangements, forKey: "numberOfArrangements")
        try container.encodeIfPresent(aggregatedBalances, forKey: "aggregatedBalances")
        try container.encodeIfPresent(additions, forKey: "additions")
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: String.self)
        id = try container.decodeIfPresent(String.self, forKey: "id")
        productKindName = try container.decodeIfPresent(String.self, forKey: "productKindName")
        balanceType = try container.decodeIfPresent(String.self, forKey: "balanceType")
        numberOfArrangements = try container.decodeIfPresent(Int.self, forKey: "numberOfArrangements")
        aggregatedBalances = try container.decodeIfPresent([AggregatedBalance].self, forKey: "aggregatedBalances")
        additions = try container.decodeIfPresent([String: String].self, forKey: "additions")
    }

    public static func ==(lhs: AccountAggregatedBalance, rhs: AccountAggregatedBalance) -> Bool {
        return lhs.id == rhs.id &&
        lhs.productKindName == rhs.productKindName &&
        lhs.balanceType == rhs.balanceType &&
        lhs.numberOfArrangements == rhs.numberOfArrangements &&
        lhs.aggregatedBalances == rhs.aggregatedBalances &&
        lhs.additions == rhs.additions
    }


}
