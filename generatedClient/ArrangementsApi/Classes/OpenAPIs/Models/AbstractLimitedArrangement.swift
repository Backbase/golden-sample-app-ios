//
// AbstractLimitedArrangement.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import ClientCommonGen2

/** Limited view of an arrangement. */
public struct AbstractLimitedArrangement: Codable, Equatable {
    /** A unique identifier for the Arrangement object that is generated and used Internally in DBS. */
    public var id: String
    /** References to the legal entities that are owners of the arrangement. */
    public var legalEntityIds: [String]
    /** The name that can be assigned by the bank to label an arrangement. */
    public var name: String?
    /** The name that can be assigned by the customer to label the arrangement. */
    public var bankAlias: String?
    /** The International Bank Account Number. If specified, it must be a valid IBAN, otherwise an invalid value error could be raised.  */
    public var IBAN: String?
    /** BBAN is the country-specific bank account number. It is short for Basic Bank Account Number. Account numbers usually match the BBAN.  */
    public var BBAN: String?
    /** The alpha-3 code (complying with ISO 4217) of the currency that qualifies the amount. */
    public var currency: String?
    /** Defines if transfer to another party is allowed. */
    public var externalTransferAllowed: Bool?
    /** Defines if urgent transfer is allowed. */
    public var urgentTransferAllowed: Bool?
    /** First 6 and/or last 4 digits of a Payment card. All other digits will/to be masked. Be aware that using card number differently is potential PCI risk. */
    public var number: String?
    /** The label/name that is used for the respective product kind */
    public var productKindName: String?
    /** The label/name that is used to label a specific product type */
    public var productTypeName: String?
    /** Bank Identifier Code - international bank code that identifies particular banks worldwide */
    public var BIC: String?
    /** A country-specific bank identification number or code: the sort code in the UK, the ACH routing number in the US, and the transit number in Canada  */
    public var bankBranchCode: String?
    /** Indicator whether or not the arrangement can be used in payment orders as credit account - account to transfer TO */
    public var creditAccount: Bool?
    /** Indicator whether or not the arrangement can be used in payment orders as debit account - account to transfer FROM */
    public var debitAccount: Bool?
    public var userPreferences: UserPreferences?
    /** Financial institution ID */
    public var financialInstitutionId: Int64?
    /** Last synchronization datetime */
    public var lastSyncDate: Date?
    public var sourceId: String?
    public var additions: [String: String]?

    @available(*, deprecated, message: "This initializer is deprecated, use the initializer and the setters of AbstractLimitedArrangement.Builder class.")
    public init(id: String, legalEntityIds: [String], name: String? = nil, bankAlias: String? = nil, IBAN: String? = nil, BBAN: String? = nil, currency: String? = nil, externalTransferAllowed: Bool? = nil, urgentTransferAllowed: Bool? = nil, number: String? = nil, productKindName: String? = nil, productTypeName: String? = nil, BIC: String? = nil, bankBranchCode: String? = nil, creditAccount: Bool? = nil, debitAccount: Bool? = nil, userPreferences: UserPreferences? = nil, financialInstitutionId: Int64? = nil, lastSyncDate: Date? = nil, sourceId: String? = nil, additions: [String: String]? = nil) {
        self.id = id
        self.legalEntityIds = legalEntityIds
        self.name = name
        self.bankAlias = bankAlias
        self.IBAN = IBAN
        self.BBAN = BBAN
        self.currency = currency
        self.externalTransferAllowed = externalTransferAllowed
        self.urgentTransferAllowed = urgentTransferAllowed
        self.number = number
        self.productKindName = productKindName
        self.productTypeName = productTypeName
        self.BIC = BIC
        self.bankBranchCode = bankBranchCode
        self.creditAccount = creditAccount
        self.debitAccount = debitAccount
        self.userPreferences = userPreferences
        self.financialInstitutionId = financialInstitutionId
        self.lastSyncDate = lastSyncDate
        self.sourceId = sourceId
        self.additions = additions
    }

    /// Builder class for AbstractLimitedArrangement DTO.
    public final class Builder: Equatable {
        /** A unique identifier for the Arrangement object that is generated and used Internally in DBS. */
        public let id: String
        /** References to the legal entities that are owners of the arrangement. */
        public let legalEntityIds: [String]
        /** The name that can be assigned by the bank to label an arrangement. */
        public private(set) var name: String?
        /** The name that can be assigned by the customer to label the arrangement. */
        public private(set) var bankAlias: String?
        /** The International Bank Account Number. If specified, it must be a valid IBAN, otherwise an invalid value error could be raised.  */
        public private(set) var IBAN: String?
        /** BBAN is the country-specific bank account number. It is short for Basic Bank Account Number. Account numbers usually match the BBAN.  */
        public private(set) var BBAN: String?
        /** The alpha-3 code (complying with ISO 4217) of the currency that qualifies the amount. */
        public private(set) var currency: String?
        /** Defines if transfer to another party is allowed. */
        public private(set) var externalTransferAllowed: Bool?
        /** Defines if urgent transfer is allowed. */
        public private(set) var urgentTransferAllowed: Bool?
        /** First 6 and/or last 4 digits of a Payment card. All other digits will/to be masked. Be aware that using card number differently is potential PCI risk. */
        public private(set) var number: String?
        /** The label/name that is used for the respective product kind */
        public private(set) var productKindName: String?
        /** The label/name that is used to label a specific product type */
        public private(set) var productTypeName: String?
        /** Bank Identifier Code - international bank code that identifies particular banks worldwide */
        public private(set) var BIC: String?
        /** A country-specific bank identification number or code: the sort code in the UK, the ACH routing number in the US, and the transit number in Canada  */
        public private(set) var bankBranchCode: String?
        /** Indicator whether or not the arrangement can be used in payment orders as credit account - account to transfer TO */
        public private(set) var creditAccount: Bool?
        /** Indicator whether or not the arrangement can be used in payment orders as debit account - account to transfer FROM */
        public private(set) var debitAccount: Bool?
        public private(set) var userPreferences: UserPreferences?
        /** Financial institution ID */
        public private(set) var financialInstitutionId: Int64?
        /** Last synchronization datetime */
        public private(set) var lastSyncDate: Date?
        public private(set) var sourceId: String?
        public private(set) var additions: [String: String]?

        public init(id: String, legalEntityIds: [String]) {
            self.id = id
            self.legalEntityIds = legalEntityIds
        }

        /// Setter method for name property.
        public func set(name: String?) -> Self {
            self.name = name
            return self
        }
        /// Setter method for bankAlias property.
        public func set(bankAlias: String?) -> Self {
            self.bankAlias = bankAlias
            return self
        }
        /// Setter method for IBAN property.
        public func set(IBAN: String?) -> Self {
            self.IBAN = IBAN
            return self
        }
        /// Setter method for BBAN property.
        public func set(BBAN: String?) -> Self {
            self.BBAN = BBAN
            return self
        }
        /// Setter method for currency property.
        public func set(currency: String?) -> Self {
            self.currency = currency
            return self
        }
        /// Setter method for externalTransferAllowed property.
        public func set(externalTransferAllowed: Bool?) -> Self {
            self.externalTransferAllowed = externalTransferAllowed
            return self
        }
        /// Setter method for urgentTransferAllowed property.
        public func set(urgentTransferAllowed: Bool?) -> Self {
            self.urgentTransferAllowed = urgentTransferAllowed
            return self
        }
        /// Setter method for number property.
        public func set(number: String?) -> Self {
            self.number = number
            return self
        }
        /// Setter method for productKindName property.
        public func set(productKindName: String?) -> Self {
            self.productKindName = productKindName
            return self
        }
        /// Setter method for productTypeName property.
        public func set(productTypeName: String?) -> Self {
            self.productTypeName = productTypeName
            return self
        }
        /// Setter method for BIC property.
        public func set(BIC: String?) -> Self {
            self.BIC = BIC
            return self
        }
        /// Setter method for bankBranchCode property.
        public func set(bankBranchCode: String?) -> Self {
            self.bankBranchCode = bankBranchCode
            return self
        }
        /// Setter method for creditAccount property.
        public func set(creditAccount: Bool?) -> Self {
            self.creditAccount = creditAccount
            return self
        }
        /// Setter method for debitAccount property.
        public func set(debitAccount: Bool?) -> Self {
            self.debitAccount = debitAccount
            return self
        }
        /// Setter method for userPreferences property.
        public func set(userPreferences: UserPreferences?) -> Self {
            self.userPreferences = userPreferences
            return self
        }
        /// Setter method for financialInstitutionId property.
        public func set(financialInstitutionId: Int64?) -> Self {
            self.financialInstitutionId = financialInstitutionId
            return self
        }
        /// Setter method for lastSyncDate property.
        public func set(lastSyncDate: Date?) -> Self {
            self.lastSyncDate = lastSyncDate
            return self
        }
        /// Setter method for sourceId property.
        public func set(sourceId: String?) -> Self {
            self.sourceId = sourceId
            return self
        }
        /// Setter method for additions property.
        public func set(additions: [String: String]?) -> Self {
            self.additions = additions
            return self
        }

        /// Builder initializer method for AbstractLimitedArrangement DTO.
        public func build() -> AbstractLimitedArrangement {
            return AbstractLimitedArrangement(id: id, 
                    legalEntityIds: legalEntityIds, 
                    name: name, 
                    bankAlias: bankAlias, 
                    IBAN: IBAN, 
                    BBAN: BBAN, 
                    currency: currency, 
                    externalTransferAllowed: externalTransferAllowed, 
                    urgentTransferAllowed: urgentTransferAllowed, 
                    number: number, 
                    productKindName: productKindName, 
                    productTypeName: productTypeName, 
                    BIC: BIC, 
                    bankBranchCode: bankBranchCode, 
                    creditAccount: creditAccount, 
                    debitAccount: debitAccount, 
                    userPreferences: userPreferences, 
                    financialInstitutionId: financialInstitutionId, 
                    lastSyncDate: lastSyncDate, 
                    sourceId: sourceId, 
                    additions: additions)
        }

        public static func ==(lhs: Builder, rhs: Builder) -> Bool {
            return lhs.id == rhs.id &&
            lhs.legalEntityIds == rhs.legalEntityIds &&
            lhs.name == rhs.name &&
            lhs.bankAlias == rhs.bankAlias &&
            lhs.IBAN == rhs.IBAN &&
            lhs.BBAN == rhs.BBAN &&
            lhs.currency == rhs.currency &&
            lhs.externalTransferAllowed == rhs.externalTransferAllowed &&
            lhs.urgentTransferAllowed == rhs.urgentTransferAllowed &&
            lhs.number == rhs.number &&
            lhs.productKindName == rhs.productKindName &&
            lhs.productTypeName == rhs.productTypeName &&
            lhs.BIC == rhs.BIC &&
            lhs.bankBranchCode == rhs.bankBranchCode &&
            lhs.creditAccount == rhs.creditAccount &&
            lhs.debitAccount == rhs.debitAccount &&
            lhs.userPreferences == rhs.userPreferences &&
            lhs.financialInstitutionId == rhs.financialInstitutionId &&
            lhs.lastSyncDate == rhs.lastSyncDate &&
            lhs.sourceId == rhs.sourceId &&
            lhs.additions == rhs.additions
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: String.self)
        try container.encode(id, forKey: "id")
        try container.encode(legalEntityIds, forKey: "legalEntityIds")
        try container.encodeIfPresent(name, forKey: "name")
        try container.encodeIfPresent(bankAlias, forKey: "bankAlias")
        try container.encodeIfPresent(IBAN, forKey: "IBAN")
        try container.encodeIfPresent(BBAN, forKey: "BBAN")
        try container.encodeIfPresent(currency, forKey: "currency")
        try container.encodeIfPresent(externalTransferAllowed, forKey: "externalTransferAllowed")
        try container.encodeIfPresent(urgentTransferAllowed, forKey: "urgentTransferAllowed")
        try container.encodeIfPresent(number, forKey: "number")
        try container.encodeIfPresent(productKindName, forKey: "productKindName")
        try container.encodeIfPresent(productTypeName, forKey: "productTypeName")
        try container.encodeIfPresent(BIC, forKey: "BIC")
        try container.encodeIfPresent(bankBranchCode, forKey: "bankBranchCode")
        try container.encodeIfPresent(creditAccount, forKey: "creditAccount")
        try container.encodeIfPresent(debitAccount, forKey: "debitAccount")
        try container.encodeIfPresent(userPreferences, forKey: "userPreferences")
        try container.encodeIfPresent(financialInstitutionId, forKey: "financialInstitutionId")
        let lastSyncDateStr: String?
        if let lastSyncDate = lastSyncDate {
            lastSyncDateStr = CodableHelper.dateTimeFormatter.string(from: lastSyncDate)
        } else {
            lastSyncDateStr = nil
        }
        try container.encodeIfPresent(lastSyncDateStr, forKey: "lastSyncDate")
        try container.encodeIfPresent(sourceId, forKey: "sourceId")
        try container.encodeIfPresent(additions, forKey: "additions")
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: String.self)
        id = try container.decode(String.self, forKey: "id")
        legalEntityIds = try container.decode([String].self, forKey: "legalEntityIds")
        name = try container.decodeIfPresent(String.self, forKey: "name")
        bankAlias = try container.decodeIfPresent(String.self, forKey: "bankAlias")
        IBAN = try container.decodeIfPresent(String.self, forKey: "IBAN")
        BBAN = try container.decodeIfPresent(String.self, forKey: "BBAN")
        currency = try container.decodeIfPresent(String.self, forKey: "currency")
        externalTransferAllowed = try container.decodeIfPresent(Bool.self, forKey: "externalTransferAllowed")
        urgentTransferAllowed = try container.decodeIfPresent(Bool.self, forKey: "urgentTransferAllowed")
        number = try container.decodeIfPresent(String.self, forKey: "number")
        productKindName = try container.decodeIfPresent(String.self, forKey: "productKindName")
        productTypeName = try container.decodeIfPresent(String.self, forKey: "productTypeName")
        BIC = try container.decodeIfPresent(String.self, forKey: "BIC")
        bankBranchCode = try container.decodeIfPresent(String.self, forKey: "bankBranchCode")
        creditAccount = try container.decodeIfPresent(Bool.self, forKey: "creditAccount")
        debitAccount = try container.decodeIfPresent(Bool.self, forKey: "debitAccount")
        userPreferences = try container.decodeIfPresent(UserPreferences.self, forKey: "userPreferences")
        financialInstitutionId = try container.decodeIfPresent(Int64.self, forKey: "financialInstitutionId")
        lastSyncDate = try CodableHelper.decodeDateTimeIfPresent(from: container, forKey: "lastSyncDate")
        sourceId = try container.decodeIfPresent(String.self, forKey: "sourceId")
        additions = try container.decodeIfPresent([String: String].self, forKey: "additions")
    }

    public static func ==(lhs: AbstractLimitedArrangement, rhs: AbstractLimitedArrangement) -> Bool {
        return lhs.id == rhs.id &&
        lhs.legalEntityIds == rhs.legalEntityIds &&
        lhs.name == rhs.name &&
        lhs.bankAlias == rhs.bankAlias &&
        lhs.IBAN == rhs.IBAN &&
        lhs.BBAN == rhs.BBAN &&
        lhs.currency == rhs.currency &&
        lhs.externalTransferAllowed == rhs.externalTransferAllowed &&
        lhs.urgentTransferAllowed == rhs.urgentTransferAllowed &&
        lhs.number == rhs.number &&
        lhs.productKindName == rhs.productKindName &&
        lhs.productTypeName == rhs.productTypeName &&
        lhs.BIC == rhs.BIC &&
        lhs.bankBranchCode == rhs.bankBranchCode &&
        lhs.creditAccount == rhs.creditAccount &&
        lhs.debitAccount == rhs.debitAccount &&
        lhs.userPreferences == rhs.userPreferences &&
        lhs.financialInstitutionId == rhs.financialInstitutionId &&
        lhs.lastSyncDate == rhs.lastSyncDate &&
        lhs.sourceId == rhs.sourceId &&
        lhs.additions == rhs.additions
    }


}
