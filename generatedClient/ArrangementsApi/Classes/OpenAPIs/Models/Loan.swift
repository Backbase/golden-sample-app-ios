//
// Loan.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import ClientCommonGen2


public struct Loan: Codable, Equatable {
    public var bookedBalance: String?
    public var principalAmount: Double?
    /** The alpha-3 code (complying with ISO 4217) of the currency that qualifies the amount. */
    public var currency: String?
    /** Defines if urgent transfer is allowed. */
    public var urgentTransferAllowed: Bool?
    /** The number identifying the contract. */
    public var productNumber: String?
    /** The annualized cost of credit or debt capital computed as the percentage ratio of interest to the principal. In the case of credit cards, the account interest rate is the annual percentage that is added monthly to the outstanding balance due on a credit card. */
    public var accountInterestRate: Double?
    public var termUnit: TimeUnit?
    /** The number of times interest rate is paid on the settlement account. */
    public var termNumber: Double?
    /** This IS the value date balance of the arrangement. */
    public var outstandingPrincipalAmount: Double?
    /** A fixed payment amount paid by a borrower to the bank at a specified date each calendar month. */
    public var monthlyInstalmentAmount: Double?
    /** The part of a debt that is overdue after missing one or more required payments. The amount of the arrears is the amount accrued from the date on which the first missed payment was due. */
    public var amountInArrear: Double?
    /** Account that provides quick access to accumulated cash to facilitate daily settlements with other businesses. */
    public var interestSettlementAccount: String?
    public var accruedInterest: Double?
    /** Party(s) with a relationship to the account. */
    public var accountHolderNames: String?
    /** End term of a holding period. */
    public var maturityDate: Date?
    /** The balance of the account on a specific date that needs to be used for the calculation of interest. NB! If no date is specified (like for the book date balance) the current date can be assumed. */
    public var valueDateBalance: Double?
    /** Indicator whether or not the arrangement can be used in payment orders as credit account. */
    public var creditAccount: Bool?
    /** Indicator whether or not the arrangement can be used in payment orders as debit account. */
    public var debitAccount: Bool?
    /** The International Bank Account Number. If specified, it must be a valid IBAN, otherwise an invalid value error could be raised.  */
    public var IBAN: String?
    /** BBAN is the country-specific bank account number. It is short for Basic Bank Account Number. Account numbers usually match the BBAN.  */
    public var BBAN: String?
    /** An optional list of the maskable attributes that can be unmasked. */
    public var unmaskableAttributes: [MaskableAttribute]?
    /** Reference to the product of which the arrangement is an instantiation. */
    public var id: String?
    public var name: String?
    /** Represents an arrangement by it&#39;s correct naming identifier. It could be account alias or user alias depending on the journey selected by the financial institution. If none of those is set, the arrangement name will be used.  */
    public var displayName: String?
    /** Defines if transfer to another party is allowed. */
    public var externalTransferAllowed: Bool?
    /** Defines if cross currency transfer is allowed */
    public var crossCurrencyAllowed: Bool?
    /** The label/name that is used for the respective product kind */
    public var productKindName: String?
    /** The label/name that is used to label a specific product type */
    public var productTypeName: String?
    /** The name that can be assigned by the bank to label the arrangement. */
    public var bankAlias: String?
    /** Indicate if the account is regular or external */
    public var sourceId: String?
    /** indicator whether to show or hide the arrangement on the widget */
    public var visible: Bool?
    public var accountOpeningDate: Date?
    /** Last date of parameter update for the arrangement. */
    public var lastUpdateDate: Date?
    public var userPreferences: UserPreferences?
    public var state: StateItem?
    /** Reference to the parent of the arrangement. */
    public var parentId: String?
    public var subArrangements: [BaseProduct]?
    /** Financial institution ID */
    public var financialInstitutionId: Int64?
    /** Last synchronization datetime */
    public var lastSyncDate: Date?
    public var cardDetails: CardDetails?
    public var interestDetails: InterestDetails?
    /** The reservation of a portion of a credit or debit balance for the cost of services not yet rendered.  */
    public var reservedAmount: Double?
    /** The limitation in periodic saving transfers or withdrawals. In the case of the US, Regulation D enables for a maximum of 6 monthly savings transfers or withdrawals.  */
    public var remainingPeriodicTransfers: Double?
    /** Another country-specific bank identification number or code: the Fedwire Routing Number in the US or another country-specific identifier.  */
    public var bankBranchCode2: String?
    /** The last day of the forthcoming billing cycle. */
    public var nextClosingDate: Date?
    /** The date in which the arrangement has been overdue since. */
    public var overdueSince: Date?
    /** DEPRECATED: the attribute is deprecated and ignored by Backend  */
    public var credentialsExpired: Bool?
    /** Synchronization statuses an account can have on the provider side after it has been aggregated.  */
    public var externalAccountStatus: String?
    public var additions: [String: String]?

    @available(*, deprecated, message: "This initializer is deprecated, use the initializer and the setters of Loan.Builder class.")
    public init(bookedBalance: String? = nil, principalAmount: Double? = nil, currency: String? = nil, urgentTransferAllowed: Bool? = nil, productNumber: String? = nil, accountInterestRate: Double? = nil, termUnit: TimeUnit? = nil, termNumber: Double? = nil, outstandingPrincipalAmount: Double? = nil, monthlyInstalmentAmount: Double? = nil, amountInArrear: Double? = nil, interestSettlementAccount: String? = nil, accruedInterest: Double? = nil, accountHolderNames: String? = nil, maturityDate: Date? = nil, valueDateBalance: Double? = nil, creditAccount: Bool? = nil, debitAccount: Bool? = nil, IBAN: String? = nil, BBAN: String? = nil, unmaskableAttributes: [MaskableAttribute]? = nil, id: String? = nil, name: String? = nil, displayName: String? = nil, externalTransferAllowed: Bool? = nil, crossCurrencyAllowed: Bool? = nil, productKindName: String? = nil, productTypeName: String? = nil, bankAlias: String? = nil, sourceId: String? = nil, visible: Bool? = nil, accountOpeningDate: Date? = nil, lastUpdateDate: Date? = nil, userPreferences: UserPreferences? = nil, state: StateItem? = nil, parentId: String? = nil, subArrangements: [BaseProduct]? = nil, financialInstitutionId: Int64? = nil, lastSyncDate: Date? = nil, cardDetails: CardDetails? = nil, interestDetails: InterestDetails? = nil, reservedAmount: Double? = nil, remainingPeriodicTransfers: Double? = nil, bankBranchCode2: String? = nil, nextClosingDate: Date? = nil, overdueSince: Date? = nil, credentialsExpired: Bool? = nil, externalAccountStatus: String? = nil, additions: [String: String]? = nil) {
        self.bookedBalance = bookedBalance
        self.principalAmount = principalAmount
        self.currency = currency
        self.urgentTransferAllowed = urgentTransferAllowed
        self.productNumber = productNumber
        self.accountInterestRate = accountInterestRate
        self.termUnit = termUnit
        self.termNumber = termNumber
        self.outstandingPrincipalAmount = outstandingPrincipalAmount
        self.monthlyInstalmentAmount = monthlyInstalmentAmount
        self.amountInArrear = amountInArrear
        self.interestSettlementAccount = interestSettlementAccount
        self.accruedInterest = accruedInterest
        self.accountHolderNames = accountHolderNames
        self.maturityDate = maturityDate
        self.valueDateBalance = valueDateBalance
        self.creditAccount = creditAccount
        self.debitAccount = debitAccount
        self.IBAN = IBAN
        self.BBAN = BBAN
        self.unmaskableAttributes = unmaskableAttributes
        self.id = id
        self.name = name
        self.displayName = displayName
        self.externalTransferAllowed = externalTransferAllowed
        self.crossCurrencyAllowed = crossCurrencyAllowed
        self.productKindName = productKindName
        self.productTypeName = productTypeName
        self.bankAlias = bankAlias
        self.sourceId = sourceId
        self.visible = visible
        self.accountOpeningDate = accountOpeningDate
        self.lastUpdateDate = lastUpdateDate
        self.userPreferences = userPreferences
        self.state = state
        self.parentId = parentId
        self.subArrangements = subArrangements
        self.financialInstitutionId = financialInstitutionId
        self.lastSyncDate = lastSyncDate
        self.cardDetails = cardDetails
        self.interestDetails = interestDetails
        self.reservedAmount = reservedAmount
        self.remainingPeriodicTransfers = remainingPeriodicTransfers
        self.bankBranchCode2 = bankBranchCode2
        self.nextClosingDate = nextClosingDate
        self.overdueSince = overdueSince
        self.credentialsExpired = credentialsExpired
        self.externalAccountStatus = externalAccountStatus
        self.additions = additions
    }

    /// Builder class for Loan DTO.
    public final class Builder: Equatable {
        public private(set) var bookedBalance: String?
        public private(set) var principalAmount: Double?
        /** The alpha-3 code (complying with ISO 4217) of the currency that qualifies the amount. */
        public private(set) var currency: String?
        /** Defines if urgent transfer is allowed. */
        public private(set) var urgentTransferAllowed: Bool?
        /** The number identifying the contract. */
        public private(set) var productNumber: String?
        /** The annualized cost of credit or debt capital computed as the percentage ratio of interest to the principal. In the case of credit cards, the account interest rate is the annual percentage that is added monthly to the outstanding balance due on a credit card. */
        public private(set) var accountInterestRate: Double?
        public private(set) var termUnit: TimeUnit?
        /** The number of times interest rate is paid on the settlement account. */
        public private(set) var termNumber: Double?
        /** This IS the value date balance of the arrangement. */
        public private(set) var outstandingPrincipalAmount: Double?
        /** A fixed payment amount paid by a borrower to the bank at a specified date each calendar month. */
        public private(set) var monthlyInstalmentAmount: Double?
        /** The part of a debt that is overdue after missing one or more required payments. The amount of the arrears is the amount accrued from the date on which the first missed payment was due. */
        public private(set) var amountInArrear: Double?
        /** Account that provides quick access to accumulated cash to facilitate daily settlements with other businesses. */
        public private(set) var interestSettlementAccount: String?
        public private(set) var accruedInterest: Double?
        /** Party(s) with a relationship to the account. */
        public private(set) var accountHolderNames: String?
        /** End term of a holding period. */
        public private(set) var maturityDate: Date?
        /** The balance of the account on a specific date that needs to be used for the calculation of interest. NB! If no date is specified (like for the book date balance) the current date can be assumed. */
        public private(set) var valueDateBalance: Double?
        /** Indicator whether or not the arrangement can be used in payment orders as credit account. */
        public private(set) var creditAccount: Bool?
        /** Indicator whether or not the arrangement can be used in payment orders as debit account. */
        public private(set) var debitAccount: Bool?
        /** The International Bank Account Number. If specified, it must be a valid IBAN, otherwise an invalid value error could be raised.  */
        public private(set) var IBAN: String?
        /** BBAN is the country-specific bank account number. It is short for Basic Bank Account Number. Account numbers usually match the BBAN.  */
        public private(set) var BBAN: String?
        /** An optional list of the maskable attributes that can be unmasked. */
        public private(set) var unmaskableAttributes: [MaskableAttribute]?
        /** Reference to the product of which the arrangement is an instantiation. */
        public private(set) var id: String?
        public private(set) var name: String?
        /** Represents an arrangement by it&#39;s correct naming identifier. It could be account alias or user alias depending on the journey selected by the financial institution. If none of those is set, the arrangement name will be used.  */
        public private(set) var displayName: String?
        /** Defines if transfer to another party is allowed. */
        public private(set) var externalTransferAllowed: Bool?
        /** Defines if cross currency transfer is allowed */
        public private(set) var crossCurrencyAllowed: Bool?
        /** The label/name that is used for the respective product kind */
        public private(set) var productKindName: String?
        /** The label/name that is used to label a specific product type */
        public private(set) var productTypeName: String?
        /** The name that can be assigned by the bank to label the arrangement. */
        public private(set) var bankAlias: String?
        /** Indicate if the account is regular or external */
        public private(set) var sourceId: String?
        /** indicator whether to show or hide the arrangement on the widget */
        public private(set) var visible: Bool?
        public private(set) var accountOpeningDate: Date?
        /** Last date of parameter update for the arrangement. */
        public private(set) var lastUpdateDate: Date?
        public private(set) var userPreferences: UserPreferences?
        public private(set) var state: StateItem?
        /** Reference to the parent of the arrangement. */
        public private(set) var parentId: String?
        public private(set) var subArrangements: [BaseProduct]?
        /** Financial institution ID */
        public private(set) var financialInstitutionId: Int64?
        /** Last synchronization datetime */
        public private(set) var lastSyncDate: Date?
        public private(set) var cardDetails: CardDetails?
        public private(set) var interestDetails: InterestDetails?
        /** The reservation of a portion of a credit or debit balance for the cost of services not yet rendered.  */
        public private(set) var reservedAmount: Double?
        /** The limitation in periodic saving transfers or withdrawals. In the case of the US, Regulation D enables for a maximum of 6 monthly savings transfers or withdrawals.  */
        public private(set) var remainingPeriodicTransfers: Double?
        /** Another country-specific bank identification number or code: the Fedwire Routing Number in the US or another country-specific identifier.  */
        public private(set) var bankBranchCode2: String?
        /** The last day of the forthcoming billing cycle. */
        public private(set) var nextClosingDate: Date?
        /** The date in which the arrangement has been overdue since. */
        public private(set) var overdueSince: Date?
        /** DEPRECATED: the attribute is deprecated and ignored by Backend  */
        public private(set) var credentialsExpired: Bool?
        /** Synchronization statuses an account can have on the provider side after it has been aggregated.  */
        public private(set) var externalAccountStatus: String?
        public private(set) var additions: [String: String]?

        public init() {
        }

        /// Setter method for bookedBalance property.
        public func set(bookedBalance: String?) -> Self {
            self.bookedBalance = bookedBalance
            return self
        }
        /// Setter method for principalAmount property.
        public func set(principalAmount: Double?) -> Self {
            self.principalAmount = principalAmount
            return self
        }
        /// Setter method for currency property.
        public func set(currency: String?) -> Self {
            self.currency = currency
            return self
        }
        /// Setter method for urgentTransferAllowed property.
        public func set(urgentTransferAllowed: Bool?) -> Self {
            self.urgentTransferAllowed = urgentTransferAllowed
            return self
        }
        /// Setter method for productNumber property.
        public func set(productNumber: String?) -> Self {
            self.productNumber = productNumber
            return self
        }
        /// Setter method for accountInterestRate property.
        public func set(accountInterestRate: Double?) -> Self {
            self.accountInterestRate = accountInterestRate
            return self
        }
        /// Setter method for termUnit property.
        public func set(termUnit: TimeUnit?) -> Self {
            self.termUnit = termUnit
            return self
        }
        /// Setter method for termNumber property.
        public func set(termNumber: Double?) -> Self {
            self.termNumber = termNumber
            return self
        }
        /// Setter method for outstandingPrincipalAmount property.
        public func set(outstandingPrincipalAmount: Double?) -> Self {
            self.outstandingPrincipalAmount = outstandingPrincipalAmount
            return self
        }
        /// Setter method for monthlyInstalmentAmount property.
        public func set(monthlyInstalmentAmount: Double?) -> Self {
            self.monthlyInstalmentAmount = monthlyInstalmentAmount
            return self
        }
        /// Setter method for amountInArrear property.
        public func set(amountInArrear: Double?) -> Self {
            self.amountInArrear = amountInArrear
            return self
        }
        /// Setter method for interestSettlementAccount property.
        public func set(interestSettlementAccount: String?) -> Self {
            self.interestSettlementAccount = interestSettlementAccount
            return self
        }
        /// Setter method for accruedInterest property.
        public func set(accruedInterest: Double?) -> Self {
            self.accruedInterest = accruedInterest
            return self
        }
        /// Setter method for accountHolderNames property.
        public func set(accountHolderNames: String?) -> Self {
            self.accountHolderNames = accountHolderNames
            return self
        }
        /// Setter method for maturityDate property.
        public func set(maturityDate: Date?) -> Self {
            self.maturityDate = maturityDate
            return self
        }
        /// Setter method for valueDateBalance property.
        public func set(valueDateBalance: Double?) -> Self {
            self.valueDateBalance = valueDateBalance
            return self
        }
        /// Setter method for creditAccount property.
        public func set(creditAccount: Bool?) -> Self {
            self.creditAccount = creditAccount
            return self
        }
        /// Setter method for debitAccount property.
        public func set(debitAccount: Bool?) -> Self {
            self.debitAccount = debitAccount
            return self
        }
        /// Setter method for IBAN property.
        public func set(IBAN: String?) -> Self {
            self.IBAN = IBAN
            return self
        }
        /// Setter method for BBAN property.
        public func set(BBAN: String?) -> Self {
            self.BBAN = BBAN
            return self
        }
        /// Setter method for unmaskableAttributes property.
        public func set(unmaskableAttributes: [MaskableAttribute]?) -> Self {
            self.unmaskableAttributes = unmaskableAttributes
            return self
        }
        /// Setter method for id property.
        public func set(id: String?) -> Self {
            self.id = id
            return self
        }
        /// Setter method for name property.
        public func set(name: String?) -> Self {
            self.name = name
            return self
        }
        /// Setter method for displayName property.
        public func set(displayName: String?) -> Self {
            self.displayName = displayName
            return self
        }
        /// Setter method for externalTransferAllowed property.
        public func set(externalTransferAllowed: Bool?) -> Self {
            self.externalTransferAllowed = externalTransferAllowed
            return self
        }
        /// Setter method for crossCurrencyAllowed property.
        public func set(crossCurrencyAllowed: Bool?) -> Self {
            self.crossCurrencyAllowed = crossCurrencyAllowed
            return self
        }
        /// Setter method for productKindName property.
        public func set(productKindName: String?) -> Self {
            self.productKindName = productKindName
            return self
        }
        /// Setter method for productTypeName property.
        public func set(productTypeName: String?) -> Self {
            self.productTypeName = productTypeName
            return self
        }
        /// Setter method for bankAlias property.
        public func set(bankAlias: String?) -> Self {
            self.bankAlias = bankAlias
            return self
        }
        /// Setter method for sourceId property.
        public func set(sourceId: String?) -> Self {
            self.sourceId = sourceId
            return self
        }
        /// Setter method for visible property.
        public func set(visible: Bool?) -> Self {
            self.visible = visible
            return self
        }
        /// Setter method for accountOpeningDate property.
        public func set(accountOpeningDate: Date?) -> Self {
            self.accountOpeningDate = accountOpeningDate
            return self
        }
        /// Setter method for lastUpdateDate property.
        public func set(lastUpdateDate: Date?) -> Self {
            self.lastUpdateDate = lastUpdateDate
            return self
        }
        /// Setter method for userPreferences property.
        public func set(userPreferences: UserPreferences?) -> Self {
            self.userPreferences = userPreferences
            return self
        }
        /// Setter method for state property.
        public func set(state: StateItem?) -> Self {
            self.state = state
            return self
        }
        /// Setter method for parentId property.
        public func set(parentId: String?) -> Self {
            self.parentId = parentId
            return self
        }
        /// Setter method for subArrangements property.
        public func set(subArrangements: [BaseProduct]?) -> Self {
            self.subArrangements = subArrangements
            return self
        }
        /// Setter method for financialInstitutionId property.
        public func set(financialInstitutionId: Int64?) -> Self {
            self.financialInstitutionId = financialInstitutionId
            return self
        }
        /// Setter method for lastSyncDate property.
        public func set(lastSyncDate: Date?) -> Self {
            self.lastSyncDate = lastSyncDate
            return self
        }
        /// Setter method for cardDetails property.
        public func set(cardDetails: CardDetails?) -> Self {
            self.cardDetails = cardDetails
            return self
        }
        /// Setter method for interestDetails property.
        public func set(interestDetails: InterestDetails?) -> Self {
            self.interestDetails = interestDetails
            return self
        }
        /// Setter method for reservedAmount property.
        public func set(reservedAmount: Double?) -> Self {
            self.reservedAmount = reservedAmount
            return self
        }
        /// Setter method for remainingPeriodicTransfers property.
        public func set(remainingPeriodicTransfers: Double?) -> Self {
            self.remainingPeriodicTransfers = remainingPeriodicTransfers
            return self
        }
        /// Setter method for bankBranchCode2 property.
        public func set(bankBranchCode2: String?) -> Self {
            self.bankBranchCode2 = bankBranchCode2
            return self
        }
        /// Setter method for nextClosingDate property.
        public func set(nextClosingDate: Date?) -> Self {
            self.nextClosingDate = nextClosingDate
            return self
        }
        /// Setter method for overdueSince property.
        public func set(overdueSince: Date?) -> Self {
            self.overdueSince = overdueSince
            return self
        }
        /// Setter method for credentialsExpired property.
        public func set(credentialsExpired: Bool?) -> Self {
            self.credentialsExpired = credentialsExpired
            return self
        }
        /// Setter method for externalAccountStatus property.
        public func set(externalAccountStatus: String?) -> Self {
            self.externalAccountStatus = externalAccountStatus
            return self
        }
        /// Setter method for additions property.
        public func set(additions: [String: String]?) -> Self {
            self.additions = additions
            return self
        }

        /// Builder initializer method for Loan DTO.
        public func build() -> Loan {
            return Loan(bookedBalance: bookedBalance, 
                    principalAmount: principalAmount, 
                    currency: currency, 
                    urgentTransferAllowed: urgentTransferAllowed, 
                    productNumber: productNumber, 
                    accountInterestRate: accountInterestRate, 
                    termUnit: termUnit, 
                    termNumber: termNumber, 
                    outstandingPrincipalAmount: outstandingPrincipalAmount, 
                    monthlyInstalmentAmount: monthlyInstalmentAmount, 
                    amountInArrear: amountInArrear, 
                    interestSettlementAccount: interestSettlementAccount, 
                    accruedInterest: accruedInterest, 
                    accountHolderNames: accountHolderNames, 
                    maturityDate: maturityDate, 
                    valueDateBalance: valueDateBalance, 
                    creditAccount: creditAccount, 
                    debitAccount: debitAccount, 
                    IBAN: IBAN, 
                    BBAN: BBAN, 
                    unmaskableAttributes: unmaskableAttributes, 
                    id: id, 
                    name: name, 
                    displayName: displayName, 
                    externalTransferAllowed: externalTransferAllowed, 
                    crossCurrencyAllowed: crossCurrencyAllowed, 
                    productKindName: productKindName, 
                    productTypeName: productTypeName, 
                    bankAlias: bankAlias, 
                    sourceId: sourceId, 
                    visible: visible, 
                    accountOpeningDate: accountOpeningDate, 
                    lastUpdateDate: lastUpdateDate, 
                    userPreferences: userPreferences, 
                    state: state, 
                    parentId: parentId, 
                    subArrangements: subArrangements, 
                    financialInstitutionId: financialInstitutionId, 
                    lastSyncDate: lastSyncDate, 
                    cardDetails: cardDetails, 
                    interestDetails: interestDetails, 
                    reservedAmount: reservedAmount, 
                    remainingPeriodicTransfers: remainingPeriodicTransfers, 
                    bankBranchCode2: bankBranchCode2, 
                    nextClosingDate: nextClosingDate, 
                    overdueSince: overdueSince, 
                    credentialsExpired: credentialsExpired, 
                    externalAccountStatus: externalAccountStatus, 
                    additions: additions)
        }

        public static func ==(lhs: Builder, rhs: Builder) -> Bool {
            return lhs.bookedBalance == rhs.bookedBalance &&
            lhs.principalAmount == rhs.principalAmount &&
            lhs.currency == rhs.currency &&
            lhs.urgentTransferAllowed == rhs.urgentTransferAllowed &&
            lhs.productNumber == rhs.productNumber &&
            lhs.accountInterestRate == rhs.accountInterestRate &&
            lhs.termUnit == rhs.termUnit &&
            lhs.termNumber == rhs.termNumber &&
            lhs.outstandingPrincipalAmount == rhs.outstandingPrincipalAmount &&
            lhs.monthlyInstalmentAmount == rhs.monthlyInstalmentAmount &&
            lhs.amountInArrear == rhs.amountInArrear &&
            lhs.interestSettlementAccount == rhs.interestSettlementAccount &&
            lhs.accruedInterest == rhs.accruedInterest &&
            lhs.accountHolderNames == rhs.accountHolderNames &&
            lhs.maturityDate == rhs.maturityDate &&
            lhs.valueDateBalance == rhs.valueDateBalance &&
            lhs.creditAccount == rhs.creditAccount &&
            lhs.debitAccount == rhs.debitAccount &&
            lhs.IBAN == rhs.IBAN &&
            lhs.BBAN == rhs.BBAN &&
            lhs.unmaskableAttributes == rhs.unmaskableAttributes &&
            lhs.id == rhs.id &&
            lhs.name == rhs.name &&
            lhs.displayName == rhs.displayName &&
            lhs.externalTransferAllowed == rhs.externalTransferAllowed &&
            lhs.crossCurrencyAllowed == rhs.crossCurrencyAllowed &&
            lhs.productKindName == rhs.productKindName &&
            lhs.productTypeName == rhs.productTypeName &&
            lhs.bankAlias == rhs.bankAlias &&
            lhs.sourceId == rhs.sourceId &&
            lhs.visible == rhs.visible &&
            lhs.accountOpeningDate == rhs.accountOpeningDate &&
            lhs.lastUpdateDate == rhs.lastUpdateDate &&
            lhs.userPreferences == rhs.userPreferences &&
            lhs.state == rhs.state &&
            lhs.parentId == rhs.parentId &&
            lhs.subArrangements == rhs.subArrangements &&
            lhs.financialInstitutionId == rhs.financialInstitutionId &&
            lhs.lastSyncDate == rhs.lastSyncDate &&
            lhs.cardDetails == rhs.cardDetails &&
            lhs.interestDetails == rhs.interestDetails &&
            lhs.reservedAmount == rhs.reservedAmount &&
            lhs.remainingPeriodicTransfers == rhs.remainingPeriodicTransfers &&
            lhs.bankBranchCode2 == rhs.bankBranchCode2 &&
            lhs.nextClosingDate == rhs.nextClosingDate &&
            lhs.overdueSince == rhs.overdueSince &&
            lhs.credentialsExpired == rhs.credentialsExpired &&
            lhs.externalAccountStatus == rhs.externalAccountStatus &&
            lhs.additions == rhs.additions
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: String.self)
        try container.encodeIfPresent(bookedBalance, forKey: "bookedBalance")
        try container.encodeIfPresent(principalAmount, forKey: "principalAmount")
        try container.encodeIfPresent(currency, forKey: "currency")
        try container.encodeIfPresent(urgentTransferAllowed, forKey: "urgentTransferAllowed")
        try container.encodeIfPresent(productNumber, forKey: "productNumber")
        try container.encodeIfPresent(accountInterestRate, forKey: "accountInterestRate")
        try container.encodeIfPresent(termUnit, forKey: "termUnit")
        try container.encodeIfPresent(termNumber, forKey: "termNumber")
        try container.encodeIfPresent(outstandingPrincipalAmount, forKey: "outstandingPrincipalAmount")
        try container.encodeIfPresent(monthlyInstalmentAmount, forKey: "monthlyInstalmentAmount")
        try container.encodeIfPresent(amountInArrear, forKey: "amountInArrear")
        try container.encodeIfPresent(interestSettlementAccount, forKey: "interestSettlementAccount")
        try container.encodeIfPresent(accruedInterest, forKey: "accruedInterest")
        try container.encodeIfPresent(accountHolderNames, forKey: "accountHolderNames")
        let maturityDateStr: String?
        if let maturityDate = maturityDate {
            maturityDateStr = CodableHelper.dateTimeFormatter.string(from: maturityDate)
        } else {
            maturityDateStr = nil
        }
        try container.encodeIfPresent(maturityDateStr, forKey: "maturityDate")
        try container.encodeIfPresent(valueDateBalance, forKey: "valueDateBalance")
        try container.encodeIfPresent(creditAccount, forKey: "creditAccount")
        try container.encodeIfPresent(debitAccount, forKey: "debitAccount")
        try container.encodeIfPresent(IBAN, forKey: "IBAN")
        try container.encodeIfPresent(BBAN, forKey: "BBAN")
        try container.encodeIfPresent(unmaskableAttributes, forKey: "unmaskableAttributes")
        try container.encodeIfPresent(id, forKey: "id")
        try container.encodeIfPresent(name, forKey: "name")
        try container.encodeIfPresent(displayName, forKey: "displayName")
        try container.encodeIfPresent(externalTransferAllowed, forKey: "externalTransferAllowed")
        try container.encodeIfPresent(crossCurrencyAllowed, forKey: "crossCurrencyAllowed")
        try container.encodeIfPresent(productKindName, forKey: "productKindName")
        try container.encodeIfPresent(productTypeName, forKey: "productTypeName")
        try container.encodeIfPresent(bankAlias, forKey: "bankAlias")
        try container.encodeIfPresent(sourceId, forKey: "sourceId")
        try container.encodeIfPresent(visible, forKey: "visible")
        let accountOpeningDateStr: String?
        if let accountOpeningDate = accountOpeningDate {
            accountOpeningDateStr = CodableHelper.dateTimeFormatter.string(from: accountOpeningDate)
        } else {
            accountOpeningDateStr = nil
        }
        try container.encodeIfPresent(accountOpeningDateStr, forKey: "accountOpeningDate")
        let lastUpdateDateStr: String?
        if let lastUpdateDate = lastUpdateDate {
            lastUpdateDateStr = CodableHelper.dateTimeFormatter.string(from: lastUpdateDate)
        } else {
            lastUpdateDateStr = nil
        }
        try container.encodeIfPresent(lastUpdateDateStr, forKey: "lastUpdateDate")
        try container.encodeIfPresent(userPreferences, forKey: "userPreferences")
        try container.encodeIfPresent(state, forKey: "state")
        try container.encodeIfPresent(parentId, forKey: "parentId")
        try container.encodeIfPresent(subArrangements, forKey: "subArrangements")
        try container.encodeIfPresent(financialInstitutionId, forKey: "financialInstitutionId")
        let lastSyncDateStr: String?
        if let lastSyncDate = lastSyncDate {
            lastSyncDateStr = CodableHelper.dateTimeFormatter.string(from: lastSyncDate)
        } else {
            lastSyncDateStr = nil
        }
        try container.encodeIfPresent(lastSyncDateStr, forKey: "lastSyncDate")
        try container.encodeIfPresent(cardDetails, forKey: "cardDetails")
        try container.encodeIfPresent(interestDetails, forKey: "interestDetails")
        try container.encodeIfPresent(reservedAmount, forKey: "reservedAmount")
        try container.encodeIfPresent(remainingPeriodicTransfers, forKey: "remainingPeriodicTransfers")
        try container.encodeIfPresent(bankBranchCode2, forKey: "bankBranchCode2")
        let nextClosingDateStr: String?
        if let nextClosingDate = nextClosingDate {
            nextClosingDateStr = CodableHelper.dateFormatter.string(from: nextClosingDate)
        } else {
            nextClosingDateStr = nil
        }
        try container.encodeIfPresent(nextClosingDateStr, forKey: "nextClosingDate")
        let overdueSinceStr: String?
        if let overdueSince = overdueSince {
            overdueSinceStr = CodableHelper.dateFormatter.string(from: overdueSince)
        } else {
            overdueSinceStr = nil
        }
        try container.encodeIfPresent(overdueSinceStr, forKey: "overdueSince")
        try container.encodeIfPresent(credentialsExpired, forKey: "credentialsExpired")
        try container.encodeIfPresent(externalAccountStatus, forKey: "externalAccountStatus")
        try container.encodeIfPresent(additions, forKey: "additions")
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: String.self)
        bookedBalance = try container.decodeIfPresent(String.self, forKey: "bookedBalance")
        principalAmount = try container.decodeIfPresent(Double.self, forKey: "principalAmount")
        currency = try container.decodeIfPresent(String.self, forKey: "currency")
        urgentTransferAllowed = try container.decodeIfPresent(Bool.self, forKey: "urgentTransferAllowed")
        productNumber = try container.decodeIfPresent(String.self, forKey: "productNumber")
        accountInterestRate = try container.decodeIfPresent(Double.self, forKey: "accountInterestRate")
        termUnit = try container.decodeIfPresent(TimeUnit.self, forKey: "termUnit")
        termNumber = try container.decodeIfPresent(Double.self, forKey: "termNumber")
        outstandingPrincipalAmount = try container.decodeIfPresent(Double.self, forKey: "outstandingPrincipalAmount")
        monthlyInstalmentAmount = try container.decodeIfPresent(Double.self, forKey: "monthlyInstalmentAmount")
        amountInArrear = try container.decodeIfPresent(Double.self, forKey: "amountInArrear")
        interestSettlementAccount = try container.decodeIfPresent(String.self, forKey: "interestSettlementAccount")
        accruedInterest = try container.decodeIfPresent(Double.self, forKey: "accruedInterest")
        accountHolderNames = try container.decodeIfPresent(String.self, forKey: "accountHolderNames")
        maturityDate = try CodableHelper.decodeDateTimeIfPresent(from: container, forKey: "maturityDate")
        valueDateBalance = try container.decodeIfPresent(Double.self, forKey: "valueDateBalance")
        creditAccount = try container.decodeIfPresent(Bool.self, forKey: "creditAccount")
        debitAccount = try container.decodeIfPresent(Bool.self, forKey: "debitAccount")
        IBAN = try container.decodeIfPresent(String.self, forKey: "IBAN")
        BBAN = try container.decodeIfPresent(String.self, forKey: "BBAN")
        unmaskableAttributes = try container.decodeIfPresent([MaskableAttribute].self, forKey: "unmaskableAttributes")
        id = try container.decodeIfPresent(String.self, forKey: "id")
        name = try container.decodeIfPresent(String.self, forKey: "name")
        displayName = try container.decodeIfPresent(String.self, forKey: "displayName")
        externalTransferAllowed = try container.decodeIfPresent(Bool.self, forKey: "externalTransferAllowed")
        crossCurrencyAllowed = try container.decodeIfPresent(Bool.self, forKey: "crossCurrencyAllowed")
        productKindName = try container.decodeIfPresent(String.self, forKey: "productKindName")
        productTypeName = try container.decodeIfPresent(String.self, forKey: "productTypeName")
        bankAlias = try container.decodeIfPresent(String.self, forKey: "bankAlias")
        sourceId = try container.decodeIfPresent(String.self, forKey: "sourceId")
        visible = try container.decodeIfPresent(Bool.self, forKey: "visible")
        accountOpeningDate = try CodableHelper.decodeDateTimeIfPresent(from: container, forKey: "accountOpeningDate")
        lastUpdateDate = try CodableHelper.decodeDateTimeIfPresent(from: container, forKey: "lastUpdateDate")
        userPreferences = try container.decodeIfPresent(UserPreferences.self, forKey: "userPreferences")
        state = try container.decodeIfPresent(StateItem.self, forKey: "state")
        parentId = try container.decodeIfPresent(String.self, forKey: "parentId")
        subArrangements = try container.decodeIfPresent([BaseProduct].self, forKey: "subArrangements")
        financialInstitutionId = try container.decodeIfPresent(Int64.self, forKey: "financialInstitutionId")
        lastSyncDate = try CodableHelper.decodeDateTimeIfPresent(from: container, forKey: "lastSyncDate")
        cardDetails = try container.decodeIfPresent(CardDetails.self, forKey: "cardDetails")
        interestDetails = try container.decodeIfPresent(InterestDetails.self, forKey: "interestDetails")
        reservedAmount = try container.decodeIfPresent(Double.self, forKey: "reservedAmount")
        remainingPeriodicTransfers = try container.decodeIfPresent(Double.self, forKey: "remainingPeriodicTransfers")
        bankBranchCode2 = try container.decodeIfPresent(String.self, forKey: "bankBranchCode2")
        nextClosingDate = try CodableHelper.decodeDateIfPresent(from: container, forKey: "nextClosingDate")
        overdueSince = try CodableHelper.decodeDateIfPresent(from: container, forKey: "overdueSince")
        credentialsExpired = try container.decodeIfPresent(Bool.self, forKey: "credentialsExpired")
        externalAccountStatus = try container.decodeIfPresent(String.self, forKey: "externalAccountStatus")
        additions = try container.decodeIfPresent([String: String].self, forKey: "additions")
    }

    public static func ==(lhs: Loan, rhs: Loan) -> Bool {
        return lhs.bookedBalance == rhs.bookedBalance &&
        lhs.principalAmount == rhs.principalAmount &&
        lhs.currency == rhs.currency &&
        lhs.urgentTransferAllowed == rhs.urgentTransferAllowed &&
        lhs.productNumber == rhs.productNumber &&
        lhs.accountInterestRate == rhs.accountInterestRate &&
        lhs.termUnit == rhs.termUnit &&
        lhs.termNumber == rhs.termNumber &&
        lhs.outstandingPrincipalAmount == rhs.outstandingPrincipalAmount &&
        lhs.monthlyInstalmentAmount == rhs.monthlyInstalmentAmount &&
        lhs.amountInArrear == rhs.amountInArrear &&
        lhs.interestSettlementAccount == rhs.interestSettlementAccount &&
        lhs.accruedInterest == rhs.accruedInterest &&
        lhs.accountHolderNames == rhs.accountHolderNames &&
        lhs.maturityDate == rhs.maturityDate &&
        lhs.valueDateBalance == rhs.valueDateBalance &&
        lhs.creditAccount == rhs.creditAccount &&
        lhs.debitAccount == rhs.debitAccount &&
        lhs.IBAN == rhs.IBAN &&
        lhs.BBAN == rhs.BBAN &&
        lhs.unmaskableAttributes == rhs.unmaskableAttributes &&
        lhs.id == rhs.id &&
        lhs.name == rhs.name &&
        lhs.displayName == rhs.displayName &&
        lhs.externalTransferAllowed == rhs.externalTransferAllowed &&
        lhs.crossCurrencyAllowed == rhs.crossCurrencyAllowed &&
        lhs.productKindName == rhs.productKindName &&
        lhs.productTypeName == rhs.productTypeName &&
        lhs.bankAlias == rhs.bankAlias &&
        lhs.sourceId == rhs.sourceId &&
        lhs.visible == rhs.visible &&
        lhs.accountOpeningDate == rhs.accountOpeningDate &&
        lhs.lastUpdateDate == rhs.lastUpdateDate &&
        lhs.userPreferences == rhs.userPreferences &&
        lhs.state == rhs.state &&
        lhs.parentId == rhs.parentId &&
        lhs.subArrangements == rhs.subArrangements &&
        lhs.financialInstitutionId == rhs.financialInstitutionId &&
        lhs.lastSyncDate == rhs.lastSyncDate &&
        lhs.cardDetails == rhs.cardDetails &&
        lhs.interestDetails == rhs.interestDetails &&
        lhs.reservedAmount == rhs.reservedAmount &&
        lhs.remainingPeriodicTransfers == rhs.remainingPeriodicTransfers &&
        lhs.bankBranchCode2 == rhs.bankBranchCode2 &&
        lhs.nextClosingDate == rhs.nextClosingDate &&
        lhs.overdueSince == rhs.overdueSince &&
        lhs.credentialsExpired == rhs.credentialsExpired &&
        lhs.externalAccountStatus == rhs.externalAccountStatus &&
        lhs.additions == rhs.additions
    }


}
