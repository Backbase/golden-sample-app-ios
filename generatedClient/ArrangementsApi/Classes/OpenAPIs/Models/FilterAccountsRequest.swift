//
// FilterAccountsRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import ClientCommonGen2


public struct FilterAccountsRequest: Codable, Equatable {
    /** Skip over pages of elements by specifying a start value for the query. */
    public var from: Int? = 0
    /** Limit the number of elements in the response (defaults to 10). */
    public var size: Int? = 10
    /** Unique Identifier of an account, e.g IBAN, BBAN or Number. */
    public var identifier: String?
    /** Unique Identifier of a customer found in the core system of the bank. */
    public var customerId: String?
    /** Party(s) with a relationship to the account. */
    public var accountHolderNames: String?

    @available(*, deprecated, message: "This initializer is deprecated, use the initializer and the setters of FilterAccountsRequest.Builder class.")
    public init(from: Int? = nil, size: Int? = nil, identifier: String? = nil, customerId: String? = nil, accountHolderNames: String? = nil) {
        self.from = from
        self.size = size
        self.identifier = identifier
        self.customerId = customerId
        self.accountHolderNames = accountHolderNames
    }

    /// Builder class for FilterAccountsRequest DTO.
    public final class Builder: Equatable {
        /** Skip over pages of elements by specifying a start value for the query. */
        public private(set) var from: Int? = 0
        /** Limit the number of elements in the response (defaults to 10). */
        public private(set) var size: Int? = 10
        /** Unique Identifier of an account, e.g IBAN, BBAN or Number. */
        public private(set) var identifier: String?
        /** Unique Identifier of a customer found in the core system of the bank. */
        public private(set) var customerId: String?
        /** Party(s) with a relationship to the account. */
        public private(set) var accountHolderNames: String?

        public init() {
        }

        /// Setter method for from property.
        public func set(from: Int?) -> Self {
            self.from = from
            return self
        }
        /// Setter method for size property.
        public func set(size: Int?) -> Self {
            self.size = size
            return self
        }
        /// Setter method for identifier property.
        public func set(identifier: String?) -> Self {
            self.identifier = identifier
            return self
        }
        /// Setter method for customerId property.
        public func set(customerId: String?) -> Self {
            self.customerId = customerId
            return self
        }
        /// Setter method for accountHolderNames property.
        public func set(accountHolderNames: String?) -> Self {
            self.accountHolderNames = accountHolderNames
            return self
        }

        /// Builder initializer method for FilterAccountsRequest DTO.
        public func build() -> FilterAccountsRequest {
            return FilterAccountsRequest(from: from, 
                    size: size, 
                    identifier: identifier, 
                    customerId: customerId, 
                    accountHolderNames: accountHolderNames)
        }

        public static func ==(lhs: Builder, rhs: Builder) -> Bool {
            return lhs.from == rhs.from &&
            lhs.size == rhs.size &&
            lhs.identifier == rhs.identifier &&
            lhs.customerId == rhs.customerId &&
            lhs.accountHolderNames == rhs.accountHolderNames
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: String.self)
        try container.encodeIfPresent(from, forKey: "from")
        try container.encodeIfPresent(size, forKey: "size")
        try container.encodeIfPresent(identifier, forKey: "identifier")
        try container.encodeIfPresent(customerId, forKey: "customerId")
        try container.encodeIfPresent(accountHolderNames, forKey: "accountHolderNames")
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: String.self)
        from = try container.decodeIfPresent(Int.self, forKey: "from")
        size = try container.decodeIfPresent(Int.self, forKey: "size")
        identifier = try container.decodeIfPresent(String.self, forKey: "identifier")
        customerId = try container.decodeIfPresent(String.self, forKey: "customerId")
        accountHolderNames = try container.decodeIfPresent(String.self, forKey: "accountHolderNames")
    }

    public static func ==(lhs: FilterAccountsRequest, rhs: FilterAccountsRequest) -> Bool {
        return lhs.from == rhs.from &&
        lhs.size == rhs.size &&
        lhs.identifier == rhs.identifier &&
        lhs.customerId == rhs.customerId &&
        lhs.accountHolderNames == rhs.accountHolderNames
    }


}
