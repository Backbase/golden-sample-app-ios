//
// ArrangementGroupVariant.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import ClientCommonGen2

/** A variant is a special data type denoting a value of any kind, be it boolean, or string, or date.  The value is represented as a string and the actual data type is specified by the &#x60;type&#x60; attribute. The consumers of a &#x60;ArrangementGroupVariant&#x60; may use the &#x60;type&#x60; attribute to represent the &#x60;value&#x60; in an appropriate way (for instance a boolean value can be displayed as a checkbox).  The &#x60;type&#x60; attribute is extensible and it&#39;s not limited to the enumeration items mentioned below. Any use of the &#x60;type&#x60; attribute must be implemented with extensibility in mind and must provide fallback cases for unknown data types.  */
public struct ArrangementGroupVariant: Codable, Equatable {
    /** One of the following - but not limited to - these values:    - BOOLEAN   - INTEGER   - DECIMAL   - STRING   - DATE   - DATETIME    - COLLECTION  */
    public var type: String? = "STRING"
    /** An optional attribute providing additional information about the attribute, like the I18N key or the original attribute name.  The value can be configured in the backend for each attribute. If there is no such configuration it defaults to the original attribute name.  */
    public var key: String?
    /** The string representation of the variant value, when the variant type is a simple type. */
    public var value: String?
    /** A collection of group elements which is filled in, when the variant type is of type COLLECTION.  The elements are tipically child attributes of an arrangement, such as debit cards or subscriptions.  */
    public var elements: [ArrangementGroupElement]?

    @available(*, deprecated, message: "This initializer is deprecated, use the initializer and the setters of ArrangementGroupVariant.Builder class.")
    public init(type: String? = nil, key: String? = nil, value: String? = nil, elements: [ArrangementGroupElement]? = nil) {
        self.type = type
        self.key = key
        self.value = value
        self.elements = elements
    }

    /// Builder class for ArrangementGroupVariant DTO.
    public final class Builder: Equatable {
        /** One of the following - but not limited to - these values:    - BOOLEAN   - INTEGER   - DECIMAL   - STRING   - DATE   - DATETIME    - COLLECTION  */
        public private(set) var type: String? = "STRING"
        /** An optional attribute providing additional information about the attribute, like the I18N key or the original attribute name.  The value can be configured in the backend for each attribute. If there is no such configuration it defaults to the original attribute name.  */
        public private(set) var key: String?
        /** The string representation of the variant value, when the variant type is a simple type. */
        public private(set) var value: String?
        /** A collection of group elements which is filled in, when the variant type is of type COLLECTION.  The elements are tipically child attributes of an arrangement, such as debit cards or subscriptions.  */
        public private(set) var elements: [ArrangementGroupElement]?

        public init() {
        }

        /// Setter method for type property.
        public func set(type: String?) -> Self {
            self.type = type
            return self
        }
        /// Setter method for key property.
        public func set(key: String?) -> Self {
            self.key = key
            return self
        }
        /// Setter method for value property.
        public func set(value: String?) -> Self {
            self.value = value
            return self
        }
        /// Setter method for elements property.
        public func set(elements: [ArrangementGroupElement]?) -> Self {
            self.elements = elements
            return self
        }

        /// Builder initializer method for ArrangementGroupVariant DTO.
        public func build() -> ArrangementGroupVariant {
            return ArrangementGroupVariant(type: type, 
                    key: key, 
                    value: value, 
                    elements: elements)
        }

        public static func ==(lhs: Builder, rhs: Builder) -> Bool {
            return lhs.type == rhs.type &&
            lhs.key == rhs.key &&
            lhs.value == rhs.value &&
            lhs.elements == rhs.elements
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: String.self)
        try container.encodeIfPresent(type, forKey: "type")
        try container.encodeIfPresent(key, forKey: "key")
        try container.encodeIfPresent(value, forKey: "value")
        try container.encodeIfPresent(elements, forKey: "elements")
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: String.self)
        type = try container.decodeIfPresent(String.self, forKey: "type")
        key = try container.decodeIfPresent(String.self, forKey: "key")
        value = try container.decodeIfPresent(String.self, forKey: "value")
        elements = try container.decodeIfPresent([ArrangementGroupElement].self, forKey: "elements")
    }

    public static func ==(lhs: ArrangementGroupVariant, rhs: ArrangementGroupVariant) -> Bool {
        return lhs.type == rhs.type &&
        lhs.key == rhs.key &&
        lhs.value == rhs.value &&
        lhs.elements == rhs.elements
    }


}
