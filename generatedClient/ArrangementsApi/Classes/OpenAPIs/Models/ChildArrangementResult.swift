//
// ChildArrangementResult.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import ClientCommonGen2

/** Child arrangement. */
public struct ChildArrangementResult: Codable, Equatable {
    /** The name that can be assigned by the bank to label an arrangement */
    public var name: String?
    /** Represents an arrangement by it&#39;s correct naming identifier. It could be account alias or user alias depending on the journey selected by the financial institution. If none of those is set, the arrangement name will be used.  */
    public var displayName: String?
    /** The alpha-3 code (complying with ISO 4217) of the currency that qualifies the amount. */
    public var currency: String
    /** Amount of money available before any adjustments have been made for deposits in transit, checks that have not yet been cleared, reserve requirements and interest received */
    public var bookedBalance: Double?
    /** The date of activation of the account in the bank&#39;s system */
    public var accountOpeningDate: Date?
    /** End term of a holding period */
    public var maturityDate: Date?
    /** Amount payable at the end of a holding period of a product (maturity date). For deposit all of the interest is usualy paid at maturity date (IF the term is shorter then one year). */
    public var maturityAmount: Double?
    public var additions: [String: String]?

    @available(*, deprecated, message: "This initializer is deprecated, use the initializer and the setters of ChildArrangementResult.Builder class.")
    public init(name: String? = nil, displayName: String? = nil, currency: String, bookedBalance: Double? = nil, accountOpeningDate: Date? = nil, maturityDate: Date? = nil, maturityAmount: Double? = nil, additions: [String: String]? = nil) {
        self.name = name
        self.displayName = displayName
        self.currency = currency
        self.bookedBalance = bookedBalance
        self.accountOpeningDate = accountOpeningDate
        self.maturityDate = maturityDate
        self.maturityAmount = maturityAmount
        self.additions = additions
    }

    /// Builder class for ChildArrangementResult DTO.
    public final class Builder: Equatable {
        /** The name that can be assigned by the bank to label an arrangement */
        public private(set) var name: String?
        /** Represents an arrangement by it&#39;s correct naming identifier. It could be account alias or user alias depending on the journey selected by the financial institution. If none of those is set, the arrangement name will be used.  */
        public private(set) var displayName: String?
        /** The alpha-3 code (complying with ISO 4217) of the currency that qualifies the amount. */
        public let currency: String
        /** Amount of money available before any adjustments have been made for deposits in transit, checks that have not yet been cleared, reserve requirements and interest received */
        public private(set) var bookedBalance: Double?
        /** The date of activation of the account in the bank&#39;s system */
        public private(set) var accountOpeningDate: Date?
        /** End term of a holding period */
        public private(set) var maturityDate: Date?
        /** Amount payable at the end of a holding period of a product (maturity date). For deposit all of the interest is usualy paid at maturity date (IF the term is shorter then one year). */
        public private(set) var maturityAmount: Double?
        public private(set) var additions: [String: String]?

        public init(currency: String) {
            self.currency = currency
        }

        /// Setter method for name property.
        public func set(name: String?) -> Self {
            self.name = name
            return self
        }
        /// Setter method for displayName property.
        public func set(displayName: String?) -> Self {
            self.displayName = displayName
            return self
        }
        /// Setter method for bookedBalance property.
        public func set(bookedBalance: Double?) -> Self {
            self.bookedBalance = bookedBalance
            return self
        }
        /// Setter method for accountOpeningDate property.
        public func set(accountOpeningDate: Date?) -> Self {
            self.accountOpeningDate = accountOpeningDate
            return self
        }
        /// Setter method for maturityDate property.
        public func set(maturityDate: Date?) -> Self {
            self.maturityDate = maturityDate
            return self
        }
        /// Setter method for maturityAmount property.
        public func set(maturityAmount: Double?) -> Self {
            self.maturityAmount = maturityAmount
            return self
        }
        /// Setter method for additions property.
        public func set(additions: [String: String]?) -> Self {
            self.additions = additions
            return self
        }

        /// Builder initializer method for ChildArrangementResult DTO.
        public func build() -> ChildArrangementResult {
            return ChildArrangementResult(name: name, 
                    displayName: displayName, 
                    currency: currency, 
                    bookedBalance: bookedBalance, 
                    accountOpeningDate: accountOpeningDate, 
                    maturityDate: maturityDate, 
                    maturityAmount: maturityAmount, 
                    additions: additions)
        }

        public static func ==(lhs: Builder, rhs: Builder) -> Bool {
            return lhs.name == rhs.name &&
            lhs.displayName == rhs.displayName &&
            lhs.currency == rhs.currency &&
            lhs.bookedBalance == rhs.bookedBalance &&
            lhs.accountOpeningDate == rhs.accountOpeningDate &&
            lhs.maturityDate == rhs.maturityDate &&
            lhs.maturityAmount == rhs.maturityAmount &&
            lhs.additions == rhs.additions
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: String.self)
        try container.encodeIfPresent(name, forKey: "name")
        try container.encodeIfPresent(displayName, forKey: "displayName")
        try container.encode(currency, forKey: "currency")
        try container.encodeIfPresent(bookedBalance, forKey: "bookedBalance")
        let accountOpeningDateStr: String?
        if let accountOpeningDate = accountOpeningDate {
            accountOpeningDateStr = CodableHelper.dateTimeFormatter.string(from: accountOpeningDate)
        } else {
            accountOpeningDateStr = nil
        }
        try container.encodeIfPresent(accountOpeningDateStr, forKey: "accountOpeningDate")
        let maturityDateStr: String?
        if let maturityDate = maturityDate {
            maturityDateStr = CodableHelper.dateTimeFormatter.string(from: maturityDate)
        } else {
            maturityDateStr = nil
        }
        try container.encodeIfPresent(maturityDateStr, forKey: "maturityDate")
        try container.encodeIfPresent(maturityAmount, forKey: "maturityAmount")
        try container.encodeIfPresent(additions, forKey: "additions")
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: String.self)
        name = try container.decodeIfPresent(String.self, forKey: "name")
        displayName = try container.decodeIfPresent(String.self, forKey: "displayName")
        currency = try container.decode(String.self, forKey: "currency")
        bookedBalance = try container.decodeIfPresent(Double.self, forKey: "bookedBalance")
        accountOpeningDate = try CodableHelper.decodeDateTimeIfPresent(from: container, forKey: "accountOpeningDate")
        maturityDate = try CodableHelper.decodeDateTimeIfPresent(from: container, forKey: "maturityDate")
        maturityAmount = try container.decodeIfPresent(Double.self, forKey: "maturityAmount")
        additions = try container.decodeIfPresent([String: String].self, forKey: "additions")
    }

    public static func ==(lhs: ChildArrangementResult, rhs: ChildArrangementResult) -> Bool {
        return lhs.name == rhs.name &&
        lhs.displayName == rhs.displayName &&
        lhs.currency == rhs.currency &&
        lhs.bookedBalance == rhs.bookedBalance &&
        lhs.accountOpeningDate == rhs.accountOpeningDate &&
        lhs.maturityDate == rhs.maturityDate &&
        lhs.maturityAmount == rhs.maturityAmount &&
        lhs.additions == rhs.additions
    }


}
