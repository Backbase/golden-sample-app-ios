//
// AbstractCardDetails.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import ClientCommonGen2


public struct AbstractCardDetails: Codable, Equatable {
    /** This field specifies the Card Provider associated with the Account.  *Example*: Maestro, Visa, Master Card, American Express or Discover.  */
    public var cardProvider: String
    /** A card can either be Secured or Unsecured.   - *true*: amount deposited in the CC determines the Limit.   - *false*: credit limit is based off various factors including the CC holder’s Credit Score,   Credit History and is determined by the lending bank.  */
    public var secured: Bool?
    /** The amount of money currently available for a bank cash advance.  This is calculated given the portion of the CashCreditLimit which has been used for Cash Advance Transactions.  */
    public var availableCashCredit: Double?
    /** The portion of the credit limit available for bank cash advance transactions..  */
    public var cashCreditLimit: Double?
    /** The Date the last payment was made on the Credit-based arrangement  */
    public var lastPaymentDate: Date?
    /** The amount of the last payment that was made on the Credit-based arrangement.  */
    public var lastPaymentAmount: Double?
    /** The charge triggered by infractions such as late credit card payments. It can be expressed as fixed amount or as percent.  *Example*:   - *12.32*: as fixed amount   - *3.14%*: as percent  */
    public var latePaymentFee: String?
    /** The date of the previous billing cycle for the arrangement.  */
    public var previousStatementDate: Date?
    /** The amount owed on the credit card as of the previous billing cycle.  */
    public var previousStatementBalance: Double?
    /** The amount owed on the credit card as of the latest billing cycle.   */
    public var statementBalance: Double?
    public var additions: [String: String]?

    @available(*, deprecated, message: "This initializer is deprecated, use the initializer and the setters of AbstractCardDetails.Builder class.")
    public init(cardProvider: String, secured: Bool? = nil, availableCashCredit: Double? = nil, cashCreditLimit: Double? = nil, lastPaymentDate: Date? = nil, lastPaymentAmount: Double? = nil, latePaymentFee: String? = nil, previousStatementDate: Date? = nil, previousStatementBalance: Double? = nil, statementBalance: Double? = nil, additions: [String: String]? = nil) {
        self.cardProvider = cardProvider
        self.secured = secured
        self.availableCashCredit = availableCashCredit
        self.cashCreditLimit = cashCreditLimit
        self.lastPaymentDate = lastPaymentDate
        self.lastPaymentAmount = lastPaymentAmount
        self.latePaymentFee = latePaymentFee
        self.previousStatementDate = previousStatementDate
        self.previousStatementBalance = previousStatementBalance
        self.statementBalance = statementBalance
        self.additions = additions
    }

    /// Builder class for AbstractCardDetails DTO.
    public final class Builder: Equatable {
        /** This field specifies the Card Provider associated with the Account.  *Example*: Maestro, Visa, Master Card, American Express or Discover.  */
        public let cardProvider: String
        /** A card can either be Secured or Unsecured.   - *true*: amount deposited in the CC determines the Limit.   - *false*: credit limit is based off various factors including the CC holder’s Credit Score,   Credit History and is determined by the lending bank.  */
        public private(set) var secured: Bool?
        /** The amount of money currently available for a bank cash advance.  This is calculated given the portion of the CashCreditLimit which has been used for Cash Advance Transactions.  */
        public private(set) var availableCashCredit: Double?
        /** The portion of the credit limit available for bank cash advance transactions..  */
        public private(set) var cashCreditLimit: Double?
        /** The Date the last payment was made on the Credit-based arrangement  */
        public private(set) var lastPaymentDate: Date?
        /** The amount of the last payment that was made on the Credit-based arrangement.  */
        public private(set) var lastPaymentAmount: Double?
        /** The charge triggered by infractions such as late credit card payments. It can be expressed as fixed amount or as percent.  *Example*:   - *12.32*: as fixed amount   - *3.14%*: as percent  */
        public private(set) var latePaymentFee: String?
        /** The date of the previous billing cycle for the arrangement.  */
        public private(set) var previousStatementDate: Date?
        /** The amount owed on the credit card as of the previous billing cycle.  */
        public private(set) var previousStatementBalance: Double?
        /** The amount owed on the credit card as of the latest billing cycle.   */
        public private(set) var statementBalance: Double?
        public private(set) var additions: [String: String]?

        public init(cardProvider: String) {
            self.cardProvider = cardProvider
        }

        /// Setter method for secured property.
        public func set(secured: Bool?) -> Self {
            self.secured = secured
            return self
        }
        /// Setter method for availableCashCredit property.
        public func set(availableCashCredit: Double?) -> Self {
            self.availableCashCredit = availableCashCredit
            return self
        }
        /// Setter method for cashCreditLimit property.
        public func set(cashCreditLimit: Double?) -> Self {
            self.cashCreditLimit = cashCreditLimit
            return self
        }
        /// Setter method for lastPaymentDate property.
        public func set(lastPaymentDate: Date?) -> Self {
            self.lastPaymentDate = lastPaymentDate
            return self
        }
        /// Setter method for lastPaymentAmount property.
        public func set(lastPaymentAmount: Double?) -> Self {
            self.lastPaymentAmount = lastPaymentAmount
            return self
        }
        /// Setter method for latePaymentFee property.
        public func set(latePaymentFee: String?) -> Self {
            self.latePaymentFee = latePaymentFee
            return self
        }
        /// Setter method for previousStatementDate property.
        public func set(previousStatementDate: Date?) -> Self {
            self.previousStatementDate = previousStatementDate
            return self
        }
        /// Setter method for previousStatementBalance property.
        public func set(previousStatementBalance: Double?) -> Self {
            self.previousStatementBalance = previousStatementBalance
            return self
        }
        /// Setter method for statementBalance property.
        public func set(statementBalance: Double?) -> Self {
            self.statementBalance = statementBalance
            return self
        }
        /// Setter method for additions property.
        public func set(additions: [String: String]?) -> Self {
            self.additions = additions
            return self
        }

        /// Builder initializer method for AbstractCardDetails DTO.
        public func build() -> AbstractCardDetails {
            return AbstractCardDetails(cardProvider: cardProvider, 
                    secured: secured, 
                    availableCashCredit: availableCashCredit, 
                    cashCreditLimit: cashCreditLimit, 
                    lastPaymentDate: lastPaymentDate, 
                    lastPaymentAmount: lastPaymentAmount, 
                    latePaymentFee: latePaymentFee, 
                    previousStatementDate: previousStatementDate, 
                    previousStatementBalance: previousStatementBalance, 
                    statementBalance: statementBalance, 
                    additions: additions)
        }

        public static func ==(lhs: Builder, rhs: Builder) -> Bool {
            return lhs.cardProvider == rhs.cardProvider &&
            lhs.secured == rhs.secured &&
            lhs.availableCashCredit == rhs.availableCashCredit &&
            lhs.cashCreditLimit == rhs.cashCreditLimit &&
            lhs.lastPaymentDate == rhs.lastPaymentDate &&
            lhs.lastPaymentAmount == rhs.lastPaymentAmount &&
            lhs.latePaymentFee == rhs.latePaymentFee &&
            lhs.previousStatementDate == rhs.previousStatementDate &&
            lhs.previousStatementBalance == rhs.previousStatementBalance &&
            lhs.statementBalance == rhs.statementBalance &&
            lhs.additions == rhs.additions
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: String.self)
        try container.encode(cardProvider, forKey: "cardProvider")
        try container.encodeIfPresent(secured, forKey: "secured")
        try container.encodeIfPresent(availableCashCredit, forKey: "availableCashCredit")
        try container.encodeIfPresent(cashCreditLimit, forKey: "cashCreditLimit")
        let lastPaymentDateStr: String?
        if let lastPaymentDate = lastPaymentDate {
            lastPaymentDateStr = CodableHelper.dateFormatter.string(from: lastPaymentDate)
        } else {
            lastPaymentDateStr = nil
        }
        try container.encodeIfPresent(lastPaymentDateStr, forKey: "lastPaymentDate")
        try container.encodeIfPresent(lastPaymentAmount, forKey: "lastPaymentAmount")
        try container.encodeIfPresent(latePaymentFee, forKey: "latePaymentFee")
        let previousStatementDateStr: String?
        if let previousStatementDate = previousStatementDate {
            previousStatementDateStr = CodableHelper.dateFormatter.string(from: previousStatementDate)
        } else {
            previousStatementDateStr = nil
        }
        try container.encodeIfPresent(previousStatementDateStr, forKey: "previousStatementDate")
        try container.encodeIfPresent(previousStatementBalance, forKey: "previousStatementBalance")
        try container.encodeIfPresent(statementBalance, forKey: "statementBalance")
        try container.encodeIfPresent(additions, forKey: "additions")
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: String.self)
        cardProvider = try container.decode(String.self, forKey: "cardProvider")
        secured = try container.decodeIfPresent(Bool.self, forKey: "secured")
        availableCashCredit = try container.decodeIfPresent(Double.self, forKey: "availableCashCredit")
        cashCreditLimit = try container.decodeIfPresent(Double.self, forKey: "cashCreditLimit")
        lastPaymentDate = try CodableHelper.decodeDateIfPresent(from: container, forKey: "lastPaymentDate")
        lastPaymentAmount = try container.decodeIfPresent(Double.self, forKey: "lastPaymentAmount")
        latePaymentFee = try container.decodeIfPresent(String.self, forKey: "latePaymentFee")
        previousStatementDate = try CodableHelper.decodeDateIfPresent(from: container, forKey: "previousStatementDate")
        previousStatementBalance = try container.decodeIfPresent(Double.self, forKey: "previousStatementBalance")
        statementBalance = try container.decodeIfPresent(Double.self, forKey: "statementBalance")
        additions = try container.decodeIfPresent([String: String].self, forKey: "additions")
    }

    public static func ==(lhs: AbstractCardDetails, rhs: AbstractCardDetails) -> Bool {
        return lhs.cardProvider == rhs.cardProvider &&
        lhs.secured == rhs.secured &&
        lhs.availableCashCredit == rhs.availableCashCredit &&
        lhs.cashCreditLimit == rhs.cashCreditLimit &&
        lhs.lastPaymentDate == rhs.lastPaymentDate &&
        lhs.lastPaymentAmount == rhs.lastPaymentAmount &&
        lhs.latePaymentFee == rhs.latePaymentFee &&
        lhs.previousStatementDate == rhs.previousStatementDate &&
        lhs.previousStatementBalance == rhs.previousStatementBalance &&
        lhs.statementBalance == rhs.statementBalance &&
        lhs.additions == rhs.additions
    }


}
