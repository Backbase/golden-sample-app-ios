//
// ArrangementViewsAPIRequestParams.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import ClientCommonGen2

public extension ArrangementViewsAPI {
    /// This class is used as a container class for request parameters for ArrangementViewsAPI.getArrangementView API call.
    struct GetArrangementViewRequestParams: Equatable {
            /** the name of the view that should be returned */
    public let viewName: String
    /** Encoded filtering expression that is applied to the arrangements collection.  The filter is applied to all groups that are defined in the view. The response contains all arrangements retained in each group. The arrangements are returned as a single group irrespective of the number of arrangements in the result. Only the first page is returned, as defined by the default group limit configuration, but the consumers of the endpoint can use pagination which is activated only when filtering is enabled.  The filter is a logical combination of simple expressions that verifies the attributes of the arrangements.  A simple expression is a relational predicate that has the form:  &#x60;&#x60;&#x60; &lt;PATH&gt; &lt;OP&gt; &lt;CONSTANTS&gt; &#x60;&#x60;&#x60;  ... where:  * **PATH**: the attribute path, e.g. &#x60;productKind.kindUri&#x60; * **OP**: relational operator as described below * **CONSTANT**: one ore more constants values, depending on the operator  The operator can be one of the following:  * **&#x60;&#x3D;&#x60;**: to test for equality or whether the value is a proper subset of the given array * **&#x60;!&#x60;**: the oposite of &#x60;&#x3D;&#x60; * **&#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x3D;&#x60;, &#x60;&gt;&#x60;**: to test for comparison  For a complete description of the expression syntax, check the community documentation.  **NOTE**: this parameter must be URL encoded.  */
    public let filter: String?
    /** Limit the number of elements on the response. Default value will be taken from configuration.  **NOTE**: pagination is active only with filtering.  */
    public let limit: Int?
    /** Pointer to the first record of the page that is going to be returned by the endpoint.  The pointer must be taken from the cursor of a previous call of the endpoint.  The endpoint returns a status of 403 (forbidden) if the cursor is invalid or if there is no arrangement that corresponds to the given cursor, with a key &#x60;account.api.arrangement.notEntitledToSee&#x60;.  **NOTE**: pagination is active only with filtering.  */
    public let cursor: String?
    /** Mapped attribute names by which arrangements will be sorted. Prefix the name with minus (-) sign to sort in descending order.  */
    public let sort: [String]?

    internal init(viewName: String, filter: String?, limit: Int?, cursor: String?, sort: [String]?) {
        self.viewName = viewName
        self.filter = filter
        self.limit = limit
        self.cursor = cursor
        self.sort = sort
    }
    /// Builder class for GetArrangementViewRequestParams DTO.
    public final class Builder: Equatable {
        /** the name of the view that should be returned */
        public let viewName: String
        /** Encoded filtering expression that is applied to the arrangements collection.  The filter is applied to all groups that are defined in the view. The response contains all arrangements retained in each group. The arrangements are returned as a single group irrespective of the number of arrangements in the result. Only the first page is returned, as defined by the default group limit configuration, but the consumers of the endpoint can use pagination which is activated only when filtering is enabled.  The filter is a logical combination of simple expressions that verifies the attributes of the arrangements.  A simple expression is a relational predicate that has the form:  &#x60;&#x60;&#x60; &lt;PATH&gt; &lt;OP&gt; &lt;CONSTANTS&gt; &#x60;&#x60;&#x60;  ... where:  * **PATH**: the attribute path, e.g. &#x60;productKind.kindUri&#x60; * **OP**: relational operator as described below * **CONSTANT**: one ore more constants values, depending on the operator  The operator can be one of the following:  * **&#x60;&#x3D;&#x60;**: to test for equality or whether the value is a proper subset of the given array * **&#x60;!&#x60;**: the oposite of &#x60;&#x3D;&#x60; * **&#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x3D;&#x60;, &#x60;&gt;&#x60;**: to test for comparison  For a complete description of the expression syntax, check the community documentation.  **NOTE**: this parameter must be URL encoded.  */
        public private(set) var filter: String?
        /** Limit the number of elements on the response. Default value will be taken from configuration.  **NOTE**: pagination is active only with filtering.  */
        public private(set) var limit: Int?
        /** Pointer to the first record of the page that is going to be returned by the endpoint.  The pointer must be taken from the cursor of a previous call of the endpoint.  The endpoint returns a status of 403 (forbidden) if the cursor is invalid or if there is no arrangement that corresponds to the given cursor, with a key &#x60;account.api.arrangement.notEntitledToSee&#x60;.  **NOTE**: pagination is active only with filtering.  */
        public private(set) var cursor: String?
        /** Mapped attribute names by which arrangements will be sorted. Prefix the name with minus (-) sign to sort in descending order.  */
        public private(set) var sort: [String]?

        public init(viewName: String) {
            self.viewName = viewName
        }

        /// Setter method for filter property.
        public func set(filter: String?) -> Self {
            self.filter = filter
            return self
        }
        /// Setter method for limit property.
        public func set(limit: Int?) -> Self {
            self.limit = limit
            return self
        }
        /// Setter method for cursor property.
        public func set(cursor: String?) -> Self {
            self.cursor = cursor
            return self
        }
        /// Setter method for sort property.
        public func set(sort: [String]?) -> Self {
            self.sort = sort
            return self
        }

        /// Builder initializer method for GetArrangementViewRequestParams DTO.
        public func build() -> GetArrangementViewRequestParams {
            return GetArrangementViewRequestParams(viewName: viewName, 
            		filter: filter, 
            		limit: limit, 
            		cursor: cursor, 
            		sort: sort)
        }

        public static func ==(lhs: Builder, rhs: Builder) -> Bool {
        	return lhs.viewName == rhs.viewName &&
        	lhs.filter == rhs.filter &&
        	lhs.limit == rhs.limit &&
        	lhs.cursor == rhs.cursor &&
        	lhs.sort?.description == rhs.sort?.description
    	}
    }

public static func ==(lhs: Self, rhs: Self) -> Bool {
    return lhs.viewName == rhs.viewName &&
    lhs.filter == rhs.filter &&
    lhs.limit == rhs.limit &&
    lhs.cursor == rhs.cursor &&
    lhs.sort?.description == rhs.sort?.description
}
    }
    /// This class is used as a container class for request parameters for ArrangementViewsAPI.getArrangementViewGroup API call.
    struct GetArrangementViewGroupRequestParams: Equatable {
            /** the name of the view that should be returned */
    public let viewName: String
    /** the name of the group that should be returned */
    public let groupName: String
    /** Encoded filtering expression that is applied to the arrangements collection.  The filter is applied to all groups that are defined in the view. The response contains all arrangements retained in each group. The arrangements are returned as a single group irrespective of the number of arrangements in the result. Only the first page is returned, as defined by the default group limit configuration.  The filter is a logical combination of simple expressions that verifies the attributes of the arrangements.  A simple expression is a relational predicate that has the form:  &#x60;&#x60;&#x60; &lt;PATH&gt; &lt;OP&gt; &lt;CONSTANTS&gt; &#x60;&#x60;&#x60;  ... where:  * **PATH**: the attribute path, e.g. &#x60;productKind.kindUri&#x60; * **OP**: relational operator as described below * **CONSTANT**: one or more constants values, depending on the operator  The operator can be one of the following:  * **&#x60;&#x3D;&#x60;**: to test for equality or whether the value is a proper subset of the given array * **&#x60;!&#x60;**: the oposite of &#x60;&#x3D;&#x60; * **&#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x3D;&#x60;, &#x60;&gt;&#x60;**: to test for comparison  For a complete description of the expression syntax, check the community documentation.  **NOTE**: this parameter must be URL encoded.  */
    public let filter: String?
    /** Limit the number of elements on the response. Default value will be taken from configuration. */
    public let limit: Int?
    /** Pointer to the first record of the page that is going to be returned by the endpoint.  The pointer must be taken from the cursor of a previous call of the endpoint.  The endpoint returns a status of 403 (forbidden) if the cursor is invalid or if there is no arrangement that corresponds to the given cursor, with a key &#x60;account.api.arrangement.notEntitledToSee&#x60;.  */
    public let cursor: String?
    /** Mapped attribute names by which arrangements will be sorted. Prefix the name with minus (-) sign to sort in descending order.  */
    public let sort: [String]?

    internal init(viewName: String, groupName: String, filter: String?, limit: Int?, cursor: String?, sort: [String]?) {
        self.viewName = viewName
        self.groupName = groupName
        self.filter = filter
        self.limit = limit
        self.cursor = cursor
        self.sort = sort
    }
    /// Builder class for GetArrangementViewGroupRequestParams DTO.
    public final class Builder: Equatable {
        /** the name of the view that should be returned */
        public let viewName: String
        /** the name of the group that should be returned */
        public let groupName: String
        /** Encoded filtering expression that is applied to the arrangements collection.  The filter is applied to all groups that are defined in the view. The response contains all arrangements retained in each group. The arrangements are returned as a single group irrespective of the number of arrangements in the result. Only the first page is returned, as defined by the default group limit configuration.  The filter is a logical combination of simple expressions that verifies the attributes of the arrangements.  A simple expression is a relational predicate that has the form:  &#x60;&#x60;&#x60; &lt;PATH&gt; &lt;OP&gt; &lt;CONSTANTS&gt; &#x60;&#x60;&#x60;  ... where:  * **PATH**: the attribute path, e.g. &#x60;productKind.kindUri&#x60; * **OP**: relational operator as described below * **CONSTANT**: one or more constants values, depending on the operator  The operator can be one of the following:  * **&#x60;&#x3D;&#x60;**: to test for equality or whether the value is a proper subset of the given array * **&#x60;!&#x60;**: the oposite of &#x60;&#x3D;&#x60; * **&#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x3D;&#x60;, &#x60;&gt;&#x60;**: to test for comparison  For a complete description of the expression syntax, check the community documentation.  **NOTE**: this parameter must be URL encoded.  */
        public private(set) var filter: String?
        /** Limit the number of elements on the response. Default value will be taken from configuration. */
        public private(set) var limit: Int?
        /** Pointer to the first record of the page that is going to be returned by the endpoint.  The pointer must be taken from the cursor of a previous call of the endpoint.  The endpoint returns a status of 403 (forbidden) if the cursor is invalid or if there is no arrangement that corresponds to the given cursor, with a key &#x60;account.api.arrangement.notEntitledToSee&#x60;.  */
        public private(set) var cursor: String?
        /** Mapped attribute names by which arrangements will be sorted. Prefix the name with minus (-) sign to sort in descending order.  */
        public private(set) var sort: [String]?

        public init(viewName: String, groupName: String) {
            self.viewName = viewName
            self.groupName = groupName
        }

        /// Setter method for filter property.
        public func set(filter: String?) -> Self {
            self.filter = filter
            return self
        }
        /// Setter method for limit property.
        public func set(limit: Int?) -> Self {
            self.limit = limit
            return self
        }
        /// Setter method for cursor property.
        public func set(cursor: String?) -> Self {
            self.cursor = cursor
            return self
        }
        /// Setter method for sort property.
        public func set(sort: [String]?) -> Self {
            self.sort = sort
            return self
        }

        /// Builder initializer method for GetArrangementViewGroupRequestParams DTO.
        public func build() -> GetArrangementViewGroupRequestParams {
            return GetArrangementViewGroupRequestParams(viewName: viewName, 
            		groupName: groupName, 
            		filter: filter, 
            		limit: limit, 
            		cursor: cursor, 
            		sort: sort)
        }

        public static func ==(lhs: Builder, rhs: Builder) -> Bool {
        	return lhs.viewName == rhs.viewName &&
        	lhs.groupName == rhs.groupName &&
        	lhs.filter == rhs.filter &&
        	lhs.limit == rhs.limit &&
        	lhs.cursor == rhs.cursor &&
        	lhs.sort?.description == rhs.sort?.description
    	}
    }

public static func ==(lhs: Self, rhs: Self) -> Bool {
    return lhs.viewName == rhs.viewName &&
    lhs.groupName == rhs.groupName &&
    lhs.filter == rhs.filter &&
    lhs.limit == rhs.limit &&
    lhs.cursor == rhs.cursor &&
    lhs.sort?.description == rhs.sort?.description
}
    }
}
