//
// AccountsAPIRequestParams.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import ClientCommonGen2

public extension AccountsAPI {
    /// This class is used as a container class for request parameters for AccountsAPI.filterAccounts API call.
    struct FilterAccountsRequestParams: Equatable {
            public let filterAccountsRequest: FilterAccountsRequest

    internal init(filterAccountsRequest: FilterAccountsRequest) {
        self.filterAccountsRequest = filterAccountsRequest
    }
    /// Builder class for FilterAccountsRequestParams DTO.
    public final class Builder: Equatable {
        public let filterAccountsRequest: FilterAccountsRequest

        public init(filterAccountsRequest: FilterAccountsRequest) {
            self.filterAccountsRequest = filterAccountsRequest
        }


        /// Builder initializer method for FilterAccountsRequestParams DTO.
        public func build() -> FilterAccountsRequestParams {
            return FilterAccountsRequestParams(filterAccountsRequest: filterAccountsRequest)
        }

        public static func ==(lhs: Builder, rhs: Builder) -> Bool {
        	return lhs.filterAccountsRequest == rhs.filterAccountsRequest
    	}
    }

public static func ==(lhs: Self, rhs: Self) -> Bool {
    return lhs.filterAccountsRequest == rhs.filterAccountsRequest
}
    }
    /// This class is used as a container class for request parameters for AccountsAPI.getBalanceHistory API call.
    struct GetBalanceHistoryRequestParams: Equatable {
                public enum Format: String, Codable, CaseIterable {
        case json = "json"
        case csv = "csv"
    }
    /** comma separated arrangement ids */
    public let arrangementIds: String
    /** Media type that is acceptable for the response. */
    public let accept: String?
    /** Bottom value of date range */
    public let dateFrom: Date?
    /** Top value of date range */
    public let dateTo: Date?
    /** Defined time period for showing graph oscillations */
    public let timePeriod: TimePeriod?
    /** Format of the response */
    public let format: Format?

    internal init(arrangementIds: String, accept: String?, dateFrom: Date?, dateTo: Date?, timePeriod: TimePeriod?, format: Format?) {
        self.arrangementIds = arrangementIds
        self.accept = accept
        self.dateFrom = dateFrom
        self.dateTo = dateTo
        self.timePeriod = timePeriod
        self.format = format
    }
    /// Builder class for GetBalanceHistoryRequestParams DTO.
    public final class Builder: Equatable {
        /** comma separated arrangement ids */
        public let arrangementIds: String
        /** Media type that is acceptable for the response. */
        public private(set) var accept: String?
        /** Bottom value of date range */
        public private(set) var dateFrom: Date?
        /** Top value of date range */
        public private(set) var dateTo: Date?
        /** Defined time period for showing graph oscillations */
        public private(set) var timePeriod: TimePeriod?
        /** Format of the response */
        public private(set) var format: AccountsAPI.GetBalanceHistoryRequestParams.Format?

        public init(arrangementIds: String) {
            self.arrangementIds = arrangementIds
        }

        /// Setter method for accept property.
        public func set(accept: String?) -> Self {
            self.accept = accept
            return self
        }
        /// Setter method for dateFrom property.
        public func set(dateFrom: Date?) -> Self {
            self.dateFrom = dateFrom
            return self
        }
        /// Setter method for dateTo property.
        public func set(dateTo: Date?) -> Self {
            self.dateTo = dateTo
            return self
        }
        /// Setter method for timePeriod property.
        public func set(timePeriod: TimePeriod?) -> Self {
            self.timePeriod = timePeriod
            return self
        }
        /// Setter method for format property.
        public func set(format: AccountsAPI.GetBalanceHistoryRequestParams.Format?) -> Self {
            self.format = format
            return self
        }

        /// Builder initializer method for GetBalanceHistoryRequestParams DTO.
        public func build() -> GetBalanceHistoryRequestParams {
            return GetBalanceHistoryRequestParams(arrangementIds: arrangementIds, 
            		accept: accept, 
            		dateFrom: dateFrom, 
            		dateTo: dateTo, 
            		timePeriod: timePeriod, 
            		format: format)
        }

        public static func ==(lhs: Builder, rhs: Builder) -> Bool {
        	return lhs.arrangementIds == rhs.arrangementIds &&
        	lhs.accept == rhs.accept &&
        	lhs.dateFrom == rhs.dateFrom &&
        	lhs.dateTo == rhs.dateTo &&
        	lhs.timePeriod == rhs.timePeriod &&
        	lhs.format == rhs.format
    	}
    }

public static func ==(lhs: Self, rhs: Self) -> Bool {
    return lhs.arrangementIds == rhs.arrangementIds &&
    lhs.accept == rhs.accept &&
    lhs.dateFrom == rhs.dateFrom &&
    lhs.dateTo == rhs.dateTo &&
    lhs.timePeriod == rhs.timePeriod &&
    lhs.format == rhs.format
}
    }
    /// This class is used as a container class for request parameters for AccountsAPI.getBalanceHistoryForArrangement API call.
    struct GetBalanceHistoryForArrangementRequestParams: Equatable {
            /** Arrangement Id */
    public let arrangementId: String
    /** Bottom value of date range */
    public let dateFrom: Date?
    /** Top value of date range */
    public let dateTo: Date?
    /** Defined time period for showing graph oscillations */
    public let timePeriod: TimePeriod?
    /** Page Number. Skip over pages of elements by specifying a start value for the query */
    public let from: Int?
    /** Limit the number of elements on the response. When used in combination with cursor, the value is allowed to be a negative number to indicate requesting records upwards from the starting point indicated by the cursor.  */
    public let size: Int?
    /** Record UUID. As an alternative for specifying &#39;from&#39; this allows to point to the record to start the selection from.  */
    public let cursor: String?

    internal init(arrangementId: String, dateFrom: Date?, dateTo: Date?, timePeriod: TimePeriod?, from: Int?, size: Int?, cursor: String?) {
        self.arrangementId = arrangementId
        self.dateFrom = dateFrom
        self.dateTo = dateTo
        self.timePeriod = timePeriod
        self.from = from
        self.size = size
        self.cursor = cursor
    }
    /// Builder class for GetBalanceHistoryForArrangementRequestParams DTO.
    public final class Builder: Equatable {
        /** Arrangement Id */
        public let arrangementId: String
        /** Bottom value of date range */
        public private(set) var dateFrom: Date?
        /** Top value of date range */
        public private(set) var dateTo: Date?
        /** Defined time period for showing graph oscillations */
        public private(set) var timePeriod: TimePeriod?
        /** Page Number. Skip over pages of elements by specifying a start value for the query */
        public private(set) var from: Int? = 0
        /** Limit the number of elements on the response. When used in combination with cursor, the value is allowed to be a negative number to indicate requesting records upwards from the starting point indicated by the cursor.  */
        public private(set) var size: Int? = 10
        /** Record UUID. As an alternative for specifying &#39;from&#39; this allows to point to the record to start the selection from.  */
        public private(set) var cursor: String? = ""

        public init(arrangementId: String) {
            self.arrangementId = arrangementId
        }

        /// Setter method for dateFrom property.
        public func set(dateFrom: Date?) -> Self {
            self.dateFrom = dateFrom
            return self
        }
        /// Setter method for dateTo property.
        public func set(dateTo: Date?) -> Self {
            self.dateTo = dateTo
            return self
        }
        /// Setter method for timePeriod property.
        public func set(timePeriod: TimePeriod?) -> Self {
            self.timePeriod = timePeriod
            return self
        }
        /// Setter method for from property.
        public func set(from: Int?) -> Self {
            self.from = from
            return self
        }
        /// Setter method for size property.
        public func set(size: Int?) -> Self {
            self.size = size
            return self
        }
        /// Setter method for cursor property.
        public func set(cursor: String?) -> Self {
            self.cursor = cursor
            return self
        }

        /// Builder initializer method for GetBalanceHistoryForArrangementRequestParams DTO.
        public func build() -> GetBalanceHistoryForArrangementRequestParams {
            return GetBalanceHistoryForArrangementRequestParams(arrangementId: arrangementId, 
            		dateFrom: dateFrom, 
            		dateTo: dateTo, 
            		timePeriod: timePeriod, 
            		from: from, 
            		size: size, 
            		cursor: cursor)
        }

        public static func ==(lhs: Builder, rhs: Builder) -> Bool {
        	return lhs.arrangementId == rhs.arrangementId &&
        	lhs.dateFrom == rhs.dateFrom &&
        	lhs.dateTo == rhs.dateTo &&
        	lhs.timePeriod == rhs.timePeriod &&
        	lhs.from == rhs.from &&
        	lhs.size == rhs.size &&
        	lhs.cursor == rhs.cursor
    	}
    }

public static func ==(lhs: Self, rhs: Self) -> Bool {
    return lhs.arrangementId == rhs.arrangementId &&
    lhs.dateFrom == rhs.dateFrom &&
    lhs.dateTo == rhs.dateTo &&
    lhs.timePeriod == rhs.timePeriod &&
    lhs.from == rhs.from &&
    lhs.size == rhs.size &&
    lhs.cursor == rhs.cursor
}
    }
}
